Microsoft (R) Macro Assembler Version 6.15.8803		    09/01/20 13:42:39
flat_wiki0.ASM						     Page 1 - 1


				    .386
				    .model flat, stdcall
				    option casemap :none
				    include masm32.inc
			      C comment * ллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
			      C            Include file for procedures in the MASM32 library
			      C           ллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл *
			      C 
			      C ; for both --> arg num, buffer
			      C ArgCl  PROTO :DWORD,:DWORD   ; GUI mode version
			      C ArgClC PROTO :DWORD,:DWORD   ; console mode version
			      C GetCL PROTO :DWORD,:DWORD
			      C 
			      C Alloc       PROTO :DWORD
			      C Free        PROTO :DWORD
			      C 
			      C comment * --------------------------
			      C         numeric and text conversions
			      C         ---------------------------- *
			      C a2dw   PROTO :DWORD
			      C atodw  PROTO :DWORD          ; return value in eax
			      C htodw  PROTO :DWORD          ; return value in eax
			      C dwtoa  PROTO :DWORD,:DWORD   ; value - buffer
			      C dw2a   PROTO :DWORD,:DWORD
			      C dw2hex PROTO :DWORD,:DWORD
			      C dw2ah  PROTO :DWORD,:DWORD
			      C 
			      C GetErrDescription PROTO :DWORD
			      C 
			      C comment * -----------------------------------
			      C         string and floating point conversions
			      C         ------------------------------------- *
			      C FloatToStr  proto stdcall fpin:QWORD, szDbl:PTR CHAR
			      C FloatToStr2	proto	stdcall fpin:QWORD, szDbl:PTR CHAR
			      C StrToFloat	proto	stdcall szIn:PTR BYTE, fpout:PTR DWORD
			      C 
			      C comment * ---------------
			      C         search algorithms
			      C         ----------------- *
			      C InString  PROTO :DWORD,:DWORD,:DWORD ; StartPos - lpszString - lpszSubStr
			      C BinSearch PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD      ; classic scanner
			      C 
			      C ; Boyer Moore based algorithms
			      C ; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			      C BMBinSearch  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD   ; complete BM
			      C BMHBinsearch PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD   ; horspool variation
			      C SBMBinSearch PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD   ; simplified version
			      C WordCount    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C comment * ---------------------------
			      C         encryption algorithms for
			      C         "one shot" or "one pass" pads
			      C         ----------------------------- *
			      C XorData PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C RolData PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C RorData PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C StrLen PROTO :DWORD ; Agner Fog's high speed string length algo
			      C 
			      C comment * ------------------------------------
			      C         zero terminated string procedures have
			      C         been renamed for consistency. Equates
			      C         to the old names are below.
			      C         -------------------------------------- *
			      C 
			      C     szappend    PROTO :DWORD,:DWORD,:DWORD
			      C     szCatStr    PROTO :DWORD,:DWORD
			      C     szCmp       PROTO :DWORD,:DWORD
			      C     szCmpi      PROTO :DWORD,:DWORD,:DWORD
			      C     szCopy      PROTO :DWORD,:DWORD
			      C     szLeft      PROTO :DWORD,:DWORD,:DWORD
			      C     szLen       PROTO :DWORD
			      C     szLower     PROTO :DWORD
			      C     szLtrim     PROTO :DWORD,:DWORD
			      C     szMid       PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C     szMultiCat  PROTO C :DWORD,:DWORD,:VARARG
			      C     szRemove    PROTO :DWORD,:DWORD,:DWORD
			      C     szRev       PROTO :DWORD,:DWORD
			      C     szRight     PROTO :DWORD,:DWORD,:DWORD
			      C     szRtrim     PROTO :DWORD,:DWORD
			      C     szTrim      PROTO :DWORD
			      C     szUpper     PROTO :DWORD
			      C 
			      C comment * ---------------------------------
			      C         the equates for the old names must
			      C         be put after the prototypes for the
			      C         procedures they are mapped to.
			      C         ----------------------------------- *
			      C 
 = szLen		      C     lnstr   equ <szLen>
 = szCmp		      C     cmpstr  equ <szCmp>
 = szCmpi		      C     cmpsi   equ <szCmpi>
 = szRev		      C     revstr  equ <szRev>
 = szLower		      C     lcase   equ <szLower>
 = szUpper		      C     ucase   equ <szUpper>
 = szLtrim		      C     ltrim   equ <szLtrim>
 = szRtrim		      C     rtrim   equ <szRtrim>
 = szTrim		      C     trim    equ <szTrim>
 = szLeft		      C     lstr    equ <szLeft>
 = szRight		      C     rstr    equ <szRight>
 = szMid		      C     midstr  equ <szMid>
			      C ; -----------------------------------------
			      C 
			      C shell PROTO :DWORD
			      C 
			      C StripRangeI PROTO :DWORD,:DWORD,:BYTE,:BYTE
			      C StripRangeX PROTO :DWORD,:DWORD,:BYTE,:BYTE
			      C 
			      C MemCopy PROTO :DWORD,:DWORD,:DWORD  ; source - dest - length
			      C memfill PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C GetAppPath   PROTO :DWORD     ; buffer has app path
			      C NameFromPath PROTO :DWORD,:DWORD
			      C GetPathOnly  PROTO :DWORD,:DWORD
			      C 
			      C exist       PROTO :DWORD
			      C filesize    PROTO :DWORD
			      C 
			      C FrameCtrl   PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C FrameWindow PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C FrameGrp    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C Frame3D PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C line    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C circle  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C DisplayBmp   PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DisplayIcon  PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C VerticalTile PROTO :DWORD,:DWORD,:DWORD
			      C SetBMcolor   PROTO :DWORD,:DWORD
			      C 
			      C BmpButton    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C StdOut       PROTO :DWORD
			      C StdIn        PROTO :DWORD,:DWORD
			      C locate       PROTO :DWORD,:DWORD
			      C ClearScreen  PROTO
			      C StripLF      PROTO :DWORD
			      C 
			      C BrowseForFolder PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C FontDialog      PROTO :DWORD,:DWORD,:DWORD
			      C ColorDialog     PROTO :DWORD,:DWORD,:DWORD
			      C PageSetupDialog PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C PrintDialog     PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C Read_File_In    PROTO :DWORD,:DWORD
			      C ofCallBack      PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C Write_To_Disk   PROTO :DWORD,:DWORD
			      C sfCallBack      PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C RichEd1         PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C RichEd2         PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C GetPercent      PROTO :DWORD,:DWORD
			      C IntMul          PROTO :DWORD,:DWORD
			      C IntDiv          PROTO :DWORD,:DWORD
			      C IntSqrt         PROTO :DWORD
			      C 
			      C nrandom         PROTO :DWORD
			      C nseed           PROTO :DWORD
			      C 
			      C ; ---------------------------------
			      C ; prototypes for pre-built dialogs
			      C ; ---------------------------------
			      C GetTextInput    PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C AboutBox        PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetFile         PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C LoadList        PROTO :DWORD,:DWORD
			      C IPtoString      PROTO :DWORD,:DWORD
			      C GetIP           PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C     MakeIP MACRO val1,val2,val3,val4
			      C         mov ah, val1
			      C         mov al, val2
			      C         rol eax, 16
			      C         mov ah, val3
			      C         mov al, val4
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C ; ----------------------------------------
			      C ; Ernie Murphy's image loading procedures
			      C ; ----------------------------------------
			      C BitmapFromFile      PROTO :DWORD
			      C BitmapFromMemory    PROTO :DWORD,:DWORD
			      C BitmapFromResource  PROTO :DWORD,:DWORD
			      C 
			      C ; -------------------
			      C ; file IO procedures
			      C ; -------------------
			      C read_disk_file  PROTO :DWORD,:DWORD,:DWORD
			      C write_disk_file PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C ; ------------------------------
			      C ; memory mapped file procedures
			      C ; ------------------------------
			      C CloseMMF  PROTO :DWORD,:DWORD
			      C CreateMMF PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C 
			      C ; ----------------
			      C ; sort procedures
			      C ; ----------------
			      C nrQsortA PROTO :DWORD,:DWORD
			      C nrQsortD PROTO :DWORD,:DWORD
			      C 
			      C CombSortA PROTO :DWORD,:DWORD
			      C CombSortD PROTO :DWORD,:DWORD
			      C 
			      C testreg PROTO
			      C 
			      C HexDump   PROTO :DWORD,:DWORD,:DWORD
			      C AsciiDump PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C ; ------------------------------------------
			      C ; ascii and 32 bit long integer conversions
			      C ; ------------------------------------------
			      C atol PROTO :DWORD
			      C ltoa PROTO :DWORD,:DWORD
			      C 
			      C ; ----------------------------
			      C ; File open and close dialogs
			      C ; ----------------------------
			      C OpenFileDialog PROTO :DWORD, :DWORD, :DWORD, :DWORD
			      C SaveFileDialog PROTO :DWORD, :DWORD, :DWORD, :DWORD
			      C 
			      C a2wc        PROTO :DWORD
			      C 
			      C ; ----------------
			      C ; array procedures
			      C ; ----------------
			      C arr_add         PROTO :DWORD,:DWORD,:DWORD
			      C arr_mul         PROTO :DWORD,:DWORD,:DWORD
			      C arr_sub         PROTO :DWORD,:DWORD,:DWORD
			      C create_array    PROTO :DWORD,:DWORD
			      C 
			      C byte_count  PROTO :DWORD,:DWORD,:DWORD
			      C 
			      C load_drives PROTO :DWORD
			      C 
			      C udw2str PROTO :DWORD,:DWORD
			      C ustr2dw PROTO :DWORD
			      C 
			      C 
			      C 
				    include kernel32.inc
			      C   ; ===========================================
			      C   ; kernel32.inc copyright MASM32 1998 - 2003
			      C   ; ===========================================
			      C 
			      C AddAtomA PROTO :DWORD
 = AddAtomA		      C AddAtom equ <AddAtomA>
			      C 
			      C AddAtomW PROTO :DWORD
			      C AllocConsole PROTO 
			      C AllocateUserPhysicalPages PROTO :DWORD,:DWORD,:DWORD
			      C AreFileApisANSI PROTO 
			      C AssignProcessToJobObject PROTO :DWORD,:DWORD
			      C BackupRead PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C BackupSeek PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C BackupWrite PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C Beep PROTO :DWORD,:DWORD
			      C BeginUpdateResourceA PROTO :DWORD,:DWORD
 = BeginUpdateResourceA	      C BeginUpdateResource equ <BeginUpdateResourceA>
			      C 
			      C BeginUpdateResourceW PROTO :DWORD,:DWORD
			      C BindIoCompletionCallback PROTO :DWORD,:DWORD,:DWORD
			      C BuildCommDCBA PROTO :DWORD,:DWORD
 = BuildCommDCBA	      C BuildCommDCB equ <BuildCommDCBA>
			      C 
			      C BuildCommDCBAndTimeoutsA PROTO :DWORD,:DWORD,:DWORD
 = BuildCommDCBAndTimeoutsA   C BuildCommDCBAndTimeouts equ <BuildCommDCBAndTimeoutsA>
			      C 
			      C BuildCommDCBAndTimeoutsW PROTO :DWORD,:DWORD,:DWORD
			      C BuildCommDCBW PROTO :DWORD,:DWORD
			      C CallNamedPipeA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = CallNamedPipeA	      C CallNamedPipe equ <CallNamedPipeA>
			      C 
			      C CallNamedPipeW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CancelDeviceWakeupRequest PROTO :DWORD
			      C CancelIo PROTO :DWORD
			      C CancelTimerQueueTimer PROTO :DWORD,:DWORD
			      C CancelWaitableTimer PROTO :DWORD
			      C ChangeTimerQueueTimer PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C ClearCommBreak PROTO :DWORD
			      C ClearCommError PROTO :DWORD,:DWORD,:DWORD
			      C CloseHandle PROTO :DWORD
			      C CommConfigDialogA PROTO :DWORD,:DWORD,:DWORD
 = CommConfigDialogA	      C CommConfigDialog equ <CommConfigDialogA>
			      C 
			      C CommConfigDialogW PROTO :DWORD,:DWORD,:DWORD
			      C CompareFileTime PROTO :DWORD,:DWORD
			      C CompareStringA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = CompareStringA	      C CompareString equ <CompareStringA>
			      C 
			      C CompareStringW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ConnectNamedPipe PROTO :DWORD,:DWORD
			      C ContinueDebugEvent PROTO :DWORD,:DWORD,:DWORD
			      C ConvertDefaultLocale PROTO :DWORD
			      C ConvertThreadToFiber PROTO :DWORD
			      C CopyFileA PROTO :DWORD,:DWORD,:DWORD
 = CopyFileA		      C CopyFile equ <CopyFileA>
			      C 
			      C CopyFileExA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = CopyFileExA		      C CopyFileEx equ <CopyFileExA>
			      C 
			      C CopyFileExW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CopyFileW PROTO :DWORD,:DWORD,:DWORD
			      C CreateConsoleScreenBuffer PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateDirectoryA PROTO :DWORD,:DWORD
 = CreateDirectoryA	      C CreateDirectory equ <CreateDirectoryA>
			      C 
			      C CreateDirectoryExA PROTO :DWORD,:DWORD,:DWORD
 = CreateDirectoryExA	      C CreateDirectoryEx equ <CreateDirectoryExA>
			      C 
			      C CreateDirectoryExW PROTO :DWORD,:DWORD,:DWORD
			      C CreateDirectoryW PROTO :DWORD,:DWORD
			      C CreateEventA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = CreateEventA		      C CreateEvent equ <CreateEventA>
			      C 
			      C CreateEventW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateFiber PROTO :DWORD,:DWORD,:DWORD
			      C CreateFileA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = CreateFileA		      C CreateFile equ <CreateFileA>
			      C 
			      C CreateFileMappingA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = CreateFileMappingA	      C CreateFileMapping equ <CreateFileMappingA>
			      C 
			      C CreateFileMappingW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateFileW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateHardLinkA PROTO :DWORD,:DWORD,:DWORD
 = CreateHardLinkA	      C CreateHardLink equ <CreateHardLinkA>
			      C 
			      C CreateHardLinkW PROTO :DWORD,:DWORD,:DWORD
			      C CreateIoCompletionPort PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateJobObjectA PROTO :DWORD,:DWORD
 = CreateJobObjectA	      C CreateJobObject equ <CreateJobObjectA>
			      C 
			      C CreateJobObjectW PROTO :DWORD,:DWORD
			      C CreateMailslotA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = CreateMailslotA	      C CreateMailslot equ <CreateMailslotA>
			      C 
			      C CreateMailslotW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateMutexA PROTO :DWORD,:DWORD,:DWORD
 = CreateMutexA		      C CreateMutex equ <CreateMutexA>
			      C 
			      C CreateMutexW PROTO :DWORD,:DWORD,:DWORD
			      C CreateNamedPipeA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = CreateNamedPipeA	      C CreateNamedPipe equ <CreateNamedPipeA>
			      C 
			      C CreateNamedPipeW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreatePipe PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateProcessA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = CreateProcessA	      C CreateProcess equ <CreateProcessA>
			      C 
			      C CreateProcessW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateRemoteThread PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateSemaphoreA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = CreateSemaphoreA	      C CreateSemaphore equ <CreateSemaphoreA>
			      C 
			      C CreateSemaphoreW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateTapePartition PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C CreateThread PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateTimerQueue PROTO 
			      C CreateTimerQueueTimer PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C CreateToolhelp32Snapshot PROTO :DWORD,:DWORD
			      C CreateWaitableTimerA PROTO :DWORD,:DWORD,:DWORD
 = CreateWaitableTimerA	      C CreateWaitableTimer equ <CreateWaitableTimerA>
			      C 
			      C CreateWaitableTimerW PROTO :DWORD,:DWORD,:DWORD
			      C DebugActiveProcess PROTO :DWORD
			      C DebugBreak PROTO 
			      C DefineDosDeviceA PROTO :DWORD,:DWORD,:DWORD
 = DefineDosDeviceA	      C DefineDosDevice equ <DefineDosDeviceA>
			      C 
			      C DefineDosDeviceW PROTO :DWORD,:DWORD,:DWORD
			      C DeleteAtom PROTO :DWORD
			      C DeleteCriticalSection PROTO :DWORD
			      C DeleteFiber PROTO :DWORD
			      C DeleteFileA PROTO :DWORD
 = DeleteFileA		      C DeleteFile equ <DeleteFileA>
			      C 
			      C DeleteFileW PROTO :DWORD
			      C DeleteTimerQueue PROTO :DWORD
			      C DeleteTimerQueueEx PROTO :DWORD,:DWORD
			      C DeleteTimerQueueTimer PROTO :DWORD,:DWORD,:DWORD
			      C DeleteVolumeMountPointA PROTO :DWORD
 = DeleteVolumeMountPointA    C DeleteVolumeMountPoint equ <DeleteVolumeMountPointA>
			      C 
			      C DeleteVolumeMountPointW PROTO :DWORD
			      C DeviceIoControl PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C DisableThreadLibraryCalls PROTO :DWORD
			      C DisconnectNamedPipe PROTO :DWORD
			      C DnsHostnameToComputerNameA PROTO :DWORD,:DWORD,:DWORD
 = DnsHostnameToComputerNam   C DnsHostnameToComputerName equ <DnsHostnameToComputerNameA>
   eA
			      C 
			      C DnsHostnameToComputerNameW PROTO :DWORD,:DWORD,:DWORD
			      C DosDateTimeToFileTime PROTO :DWORD,:DWORD,:DWORD
			      C DuplicateHandle PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C EndUpdateResourceA PROTO :DWORD,:DWORD
 = EndUpdateResourceA	      C EndUpdateResource equ <EndUpdateResourceA>
			      C 
			      C EndUpdateResourceW PROTO :DWORD,:DWORD
			      C EnterCriticalSection PROTO :DWORD
			      C EnumCalendarInfoA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = EnumCalendarInfoA	      C EnumCalendarInfo equ <EnumCalendarInfoA>
			      C 
			      C EnumCalendarInfoExA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = EnumCalendarInfoExA	      C EnumCalendarInfoEx equ <EnumCalendarInfoExA>
			      C 
			      C EnumCalendarInfoExW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C EnumCalendarInfoW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C EnumDateFormatsA PROTO :DWORD,:DWORD,:DWORD
 = EnumDateFormatsA	      C EnumDateFormats equ <EnumDateFormatsA>
			      C 
			      C EnumDateFormatsExA PROTO :DWORD,:DWORD,:DWORD
 = EnumDateFormatsExA	      C EnumDateFormatsEx equ <EnumDateFormatsExA>
			      C 
			      C EnumDateFormatsExW PROTO :DWORD,:DWORD,:DWORD
			      C EnumDateFormatsW PROTO :DWORD,:DWORD,:DWORD
			      C EnumLanguageGroupLocalesA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = EnumLanguageGroupLocales   C EnumLanguageGroupLocales equ <EnumLanguageGroupLocalesA>
   A
			      C 
			      C EnumLanguageGroupLocalesW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C EnumResourceLanguagesA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = EnumResourceLanguagesA     C EnumResourceLanguages equ <EnumResourceLanguagesA>
			      C 
			      C EnumResourceLanguagesW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C EnumResourceNamesA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = EnumResourceNamesA	      C EnumResourceNames equ <EnumResourceNamesA>
			      C 
			      C EnumResourceNamesW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C EnumResourceTypesA PROTO :DWORD,:DWORD,:DWORD
 = EnumResourceTypesA	      C EnumResourceTypes equ <EnumResourceTypesA>
			      C 
			      C EnumResourceTypesW PROTO :DWORD,:DWORD,:DWORD
			      C EnumSystemCodePagesA PROTO :DWORD,:DWORD
 = EnumSystemCodePagesA	      C EnumSystemCodePages equ <EnumSystemCodePagesA>
			      C 
			      C EnumSystemCodePagesW PROTO :DWORD,:DWORD
			      C EnumSystemLanguageGroupsA PROTO :DWORD,:DWORD,:DWORD
 = EnumSystemLanguageGroups   C EnumSystemLanguageGroups equ <EnumSystemLanguageGroupsA>
   A
			      C 
			      C EnumSystemLanguageGroupsW PROTO :DWORD,:DWORD,:DWORD
			      C EnumSystemLocalesA PROTO :DWORD,:DWORD
 = EnumSystemLocalesA	      C EnumSystemLocales equ <EnumSystemLocalesA>
			      C 
			      C EnumSystemLocalesW PROTO :DWORD,:DWORD
			      C EnumTimeFormatsA PROTO :DWORD,:DWORD,:DWORD
 = EnumTimeFormatsA	      C EnumTimeFormats equ <EnumTimeFormatsA>
			      C 
			      C EnumTimeFormatsW PROTO :DWORD,:DWORD,:DWORD
			      C EnumUILanguagesA PROTO :DWORD,:DWORD,:DWORD
 = EnumUILanguagesA	      C EnumUILanguages equ <EnumUILanguagesA>
			      C 
			      C EnumUILanguagesW PROTO :DWORD,:DWORD,:DWORD
			      C EraseTape PROTO :DWORD,:DWORD,:DWORD
			      C EscapeCommFunction PROTO :DWORD,:DWORD
			      C ExitProcess PROTO :DWORD
			      C ExitThread PROTO :DWORD
			      C ExpandEnvironmentStringsA PROTO :DWORD,:DWORD,:DWORD
 = ExpandEnvironmentStrings   C ExpandEnvironmentStrings equ <ExpandEnvironmentStringsA>
   A
			      C 
			      C ExpandEnvironmentStringsW PROTO :DWORD,:DWORD,:DWORD
			      C FatalAppExitA PROTO :DWORD,:DWORD
 = FatalAppExitA	      C FatalAppExit equ <FatalAppExitA>
			      C 
			      C FatalAppExitW PROTO :DWORD,:DWORD
			      C FatalExit PROTO :DWORD
			      C FileTimeToDosDateTime PROTO :DWORD,:DWORD,:DWORD
			      C FileTimeToLocalFileTime PROTO :DWORD,:DWORD
			      C FileTimeToSystemTime PROTO :DWORD,:DWORD
			      C FillConsoleOutputAttribute PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C FillConsoleOutputCharacterA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = FillConsoleOutputCharact   C FillConsoleOutputCharacter equ <FillConsoleOutputCharacterA>
   erA
			      C 
			      C FillConsoleOutputCharacterW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C FindAtomA PROTO :DWORD
 = FindAtomA		      C FindAtom equ <FindAtomA>
			      C 
			      C FindAtomW PROTO :DWORD
			      C FindClose PROTO :DWORD
			      C FindCloseChangeNotification PROTO :DWORD
			      C FindFirstChangeNotificationA PROTO :DWORD,:DWORD,:DWORD
 = FindFirstChangeNotificat   C FindFirstChangeNotification equ <FindFirstChangeNotificationA>
   ionA
			      C 
			      C FindFirstChangeNotificationW PROTO :DWORD,:DWORD,:DWORD
			      C FindFirstFileA PROTO :DWORD,:DWORD
 = FindFirstFileA	      C FindFirstFile equ <FindFirstFileA>
			      C 
			      C FindFirstFileExA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = FindFirstFileExA	      C FindFirstFileEx equ <FindFirstFileExA>
			      C 
			      C FindFirstFileExW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C FindFirstFileW PROTO :DWORD,:DWORD
			      C FindFirstVolumeA PROTO :DWORD,:DWORD
 = FindFirstVolumeA	      C FindFirstVolume equ <FindFirstVolumeA>
			      C 
			      C FindFirstVolumeMountPointA PROTO :DWORD,:DWORD,:DWORD
 = FindFirstVolumeMountPoin   C FindFirstVolumeMountPoint equ <FindFirstVolumeMountPointA>
   tA
			      C 
			      C FindFirstVolumeMountPointW PROTO :DWORD,:DWORD,:DWORD
			      C FindFirstVolumeW PROTO :DWORD,:DWORD
			      C FindNextChangeNotification PROTO :DWORD
			      C FindNextFileA PROTO :DWORD,:DWORD
 = FindNextFileA	      C FindNextFile equ <FindNextFileA>
			      C 
			      C FindNextFileW PROTO :DWORD,:DWORD
			      C FindNextVolumeA PROTO :DWORD,:DWORD,:DWORD
 = FindNextVolumeA	      C FindNextVolume equ <FindNextVolumeA>
			      C 
			      C FindNextVolumeMountPointA PROTO :DWORD,:DWORD,:DWORD
 = FindNextVolumeMountPoint   C FindNextVolumeMountPoint equ <FindNextVolumeMountPointA>
   A
			      C 
			      C FindNextVolumeMountPointW PROTO :DWORD,:DWORD,:DWORD
			      C FindNextVolumeW PROTO :DWORD,:DWORD,:DWORD
			      C FindResourceA PROTO :DWORD,:DWORD,:DWORD
 = FindResourceA	      C FindResource equ <FindResourceA>
			      C 
			      C FindResourceExA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = FindResourceExA	      C FindResourceEx equ <FindResourceExA>
			      C 
			      C FindResourceExW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C FindResourceW PROTO :DWORD,:DWORD,:DWORD
			      C FindVolumeClose PROTO :DWORD
			      C FindVolumeMountPointClose PROTO :DWORD
			      C FlushConsoleInputBuffer PROTO :DWORD
			      C FlushFileBuffers PROTO :DWORD
			      C FlushInstructionCache PROTO :DWORD,:DWORD,:DWORD
			      C FlushViewOfFile PROTO :DWORD,:DWORD
			      C FoldStringA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = FoldStringA		      C FoldString equ <FoldStringA>
			      C 
			      C FoldStringW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C FormatMessageA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = FormatMessageA	      C FormatMessage equ <FormatMessageA>
			      C 
			      C FormatMessageW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C FreeConsole PROTO 
			      C FreeEnvironmentStringsA PROTO :DWORD
 = FreeEnvironmentStringsA    C FreeEnvironmentStrings equ <FreeEnvironmentStringsA>
			      C 
			      C FreeEnvironmentStringsW PROTO :DWORD
			      C FreeLibrary PROTO :DWORD
			      C FreeLibraryAndExitThread PROTO :DWORD,:DWORD
			      C FreeResource PROTO :DWORD
			      C FreeUserPhysicalPages PROTO :DWORD,:DWORD,:DWORD
			      C GenerateConsoleCtrlEvent PROTO :DWORD,:DWORD
			      C GetACP PROTO 
			      C GetAtomNameA PROTO :DWORD,:DWORD,:DWORD
 = GetAtomNameA		      C GetAtomName equ <GetAtomNameA>
			      C 
			      C GetAtomNameW PROTO :DWORD,:DWORD,:DWORD
			      C GetBinaryTypeA PROTO :DWORD,:DWORD
 = GetBinaryTypeA	      C GetBinaryType equ <GetBinaryTypeA>
			      C 
			      C GetBinaryTypeW PROTO :DWORD,:DWORD
			      C GetCPInfo PROTO :DWORD,:DWORD
			      C GetCPInfoExA PROTO :DWORD,:DWORD,:DWORD
 = GetCPInfoExA		      C GetCPInfoEx equ <GetCPInfoExA>
			      C 
			      C GetCPInfoExW PROTO :DWORD,:DWORD,:DWORD
			      C GetCalendarInfoA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetCalendarInfoA	      C GetCalendarInfo equ <GetCalendarInfoA>
			      C 
			      C GetCalendarInfoW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetCommConfig PROTO :DWORD,:DWORD,:DWORD
			      C GetCommMask PROTO :DWORD,:DWORD
			      C GetCommModemStatus PROTO :DWORD,:DWORD
			      C GetCommProperties PROTO :DWORD,:DWORD
			      C GetCommState PROTO :DWORD,:DWORD
			      C GetCommTimeouts PROTO :DWORD,:DWORD
			      C GetCommandLineA PROTO 
 = GetCommandLineA	      C GetCommandLine equ <GetCommandLineA>
			      C 
			      C GetCommandLineW PROTO 
			      C GetCompressedFileSizeA PROTO :DWORD,:DWORD
 = GetCompressedFileSizeA     C GetCompressedFileSize equ <GetCompressedFileSizeA>
			      C 
			      C GetCompressedFileSizeW PROTO :DWORD,:DWORD
			      C GetComputerNameA PROTO :DWORD,:DWORD
 = GetComputerNameA	      C GetComputerName equ <GetComputerNameA>
			      C 
			      C GetComputerNameExA PROTO :DWORD,:DWORD,:DWORD
 = GetComputerNameExA	      C GetComputerNameEx equ <GetComputerNameExA>
			      C 
			      C GetComputerNameExW PROTO :DWORD,:DWORD,:DWORD
			      C GetComputerNameW PROTO :DWORD,:DWORD
			      C GetConsoleCP PROTO 
			      C GetConsoleCursorInfo PROTO :DWORD,:DWORD
			      C GetConsoleMode PROTO :DWORD,:DWORD
			      C GetConsoleOutputCP PROTO 
			      C GetConsoleScreenBufferInfo PROTO :DWORD,:DWORD
			      C GetConsoleTitleA PROTO :DWORD,:DWORD
 = GetConsoleTitleA	      C GetConsoleTitle equ <GetConsoleTitleA>
			      C 
			      C GetConsoleTitleW PROTO :DWORD,:DWORD
			      C GetCurrencyFormatA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetCurrencyFormatA	      C GetCurrencyFormat equ <GetCurrencyFormatA>
			      C 
			      C GetCurrencyFormatW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetCurrentDirectoryA PROTO :DWORD,:DWORD
 = GetCurrentDirectoryA	      C GetCurrentDirectory equ <GetCurrentDirectoryA>
			      C 
			      C GetCurrentDirectoryW PROTO :DWORD,:DWORD
			      C GetCurrentProcess PROTO 
			      C GetCurrentProcessId PROTO 
			      C GetCurrentThread PROTO 
			      C GetCurrentThreadId PROTO 
			      C GetDateFormatA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetDateFormatA	      C GetDateFormat equ <GetDateFormatA>
			      C 
			      C GetDateFormatW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetDefaultCommConfigA PROTO :DWORD,:DWORD,:DWORD
 = GetDefaultCommConfigA      C GetDefaultCommConfig equ <GetDefaultCommConfigA>
			      C 
			      C GetDefaultCommConfigW PROTO :DWORD,:DWORD,:DWORD
			      C GetDevicePowerState PROTO :DWORD,:DWORD
			      C GetDiskFreeSpaceA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetDiskFreeSpaceA	      C GetDiskFreeSpace equ <GetDiskFreeSpaceA>
			      C 
			      C GetDiskFreeSpaceExA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = GetDiskFreeSpaceExA	      C GetDiskFreeSpaceEx equ <GetDiskFreeSpaceExA>
			      C 
			      C GetDiskFreeSpaceExW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetDiskFreeSpaceW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetDriveTypeA PROTO :DWORD
 = GetDriveTypeA	      C GetDriveType equ <GetDriveTypeA>
			      C 
			      C GetDriveTypeW PROTO :DWORD
			      C GetEnvironmentStringsA PROTO 
 = GetEnvironmentStringsA     C GetEnvironmentStrings equ <GetEnvironmentStringsA>
			      C 
			      C GetEnvironmentStringsW PROTO 
			      C GetEnvironmentVariableA PROTO :DWORD,:DWORD,:DWORD
 = GetEnvironmentVariableA    C GetEnvironmentVariable equ <GetEnvironmentVariableA>
			      C 
			      C GetEnvironmentVariableW PROTO :DWORD,:DWORD,:DWORD
			      C GetExitCodeProcess PROTO :DWORD,:DWORD
			      C GetExitCodeThread PROTO :DWORD,:DWORD
			      C GetFileAttributesA PROTO :DWORD
 = GetFileAttributesA	      C GetFileAttributes equ <GetFileAttributesA>
			      C 
			      C GetFileAttributesExA PROTO :DWORD,:DWORD,:DWORD
 = GetFileAttributesExA	      C GetFileAttributesEx equ <GetFileAttributesExA>
			      C 
			      C GetFileAttributesExW PROTO :DWORD,:DWORD,:DWORD
			      C GetFileAttributesW PROTO :DWORD
			      C GetFileInformationByHandle PROTO :DWORD,:DWORD
			      C GetFileSize PROTO :DWORD,:DWORD
			      C GetFileSizeEx PROTO :DWORD,:DWORD
			      C GetFileTime PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetFileType PROTO :DWORD
			      C GetFullPathNameA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = GetFullPathNameA	      C GetFullPathName equ <GetFullPathNameA>
			      C 
			      C GetFullPathNameW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetHandleInformation PROTO :DWORD,:DWORD
			      C GetLargestConsoleWindowSize PROTO :DWORD
			      C GetLastError PROTO 
			      C GetLocalTime PROTO :DWORD
			      C GetLocaleInfoA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = GetLocaleInfoA	      C GetLocaleInfo equ <GetLocaleInfoA>
			      C 
			      C GetLocaleInfoW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetLogicalDriveStringsA PROTO :DWORD,:DWORD
 = GetLogicalDriveStringsA    C GetLogicalDriveStrings equ <GetLogicalDriveStringsA>
			      C 
			      C GetLogicalDriveStringsW PROTO :DWORD,:DWORD
			      C GetLogicalDrives PROTO 
			      C GetLongPathNameA PROTO :DWORD,:DWORD,:DWORD
 = GetLongPathNameA	      C GetLongPathName equ <GetLongPathNameA>
			      C 
			      C GetLongPathNameW PROTO :DWORD,:DWORD,:DWORD
			      C GetMailslotInfo PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetModuleFileNameA PROTO :DWORD,:DWORD,:DWORD
 = GetModuleFileNameA	      C GetModuleFileName equ <GetModuleFileNameA>
			      C 
			      C GetModuleFileNameW PROTO :DWORD,:DWORD,:DWORD
			      C GetModuleHandleA PROTO :DWORD
 = GetModuleHandleA	      C GetModuleHandle equ <GetModuleHandleA>
			      C 
			      C GetModuleHandleW PROTO :DWORD
			      C GetNamedPipeHandleStateA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetNamedPipeHandleStateA   C GetNamedPipeHandleState equ <GetNamedPipeHandleStateA>
			      C 
			      C GetNamedPipeHandleStateW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetNamedPipeInfo PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetNumberFormatA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetNumberFormatA	      C GetNumberFormat equ <GetNumberFormatA>
			      C 
			      C GetNumberFormatW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetNumberOfConsoleInputEvents PROTO :DWORD,:DWORD
			      C GetNumberOfConsoleMouseButtons PROTO :DWORD
			      C GetOEMCP PROTO 
			      C GetOverlappedResult PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetPriorityClass PROTO :DWORD
			      C GetPrivateProfileIntA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = GetPrivateProfileIntA      C GetPrivateProfileInt equ <GetPrivateProfileIntA>
			      C 
			      C GetPrivateProfileIntW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetPrivateProfileSectionA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = GetPrivateProfileSection   C GetPrivateProfileSection equ <GetPrivateProfileSectionA>
   A
			      C 
			      C GetPrivateProfileSectionNamesA PROTO :DWORD,:DWORD,:DWORD
 = GetPrivateProfileSection   C GetPrivateProfileSectionNames equ <GetPrivateProfileSectionNamesA>
   NamesA
			      C 
			      C GetPrivateProfileSectionNamesW PROTO :DWORD,:DWORD,:DWORD
			      C GetPrivateProfileSectionW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetPrivateProfileStringA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetPrivateProfileStringA   C GetPrivateProfileString equ <GetPrivateProfileStringA>
			      C 
			      C GetPrivateProfileStringW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetPrivateProfileStructA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetPrivateProfileStructA   C GetPrivateProfileStruct equ <GetPrivateProfileStructA>
			      C 
			      C GetPrivateProfileStructW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetProcAddress PROTO :DWORD,:DWORD
			      C GetProcessAffinityMask PROTO :DWORD,:DWORD,:DWORD
			      C GetProcessHeap PROTO 
			      C GetProcessHeaps PROTO :DWORD,:DWORD
			      C GetProcessIoCounters PROTO :DWORD,:DWORD
			      C GetProcessPriorityBoost PROTO :DWORD,:DWORD
			      C GetProcessShutdownParameters PROTO :DWORD,:DWORD
			      C GetProcessTimes PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetProcessVersion PROTO :DWORD
			      C GetProcessWorkingSetSize PROTO :DWORD,:DWORD,:DWORD
			      C GetProfileIntA PROTO :DWORD,:DWORD,:DWORD
 = GetProfileIntA	      C GetProfileInt equ <GetProfileIntA>
			      C 
			      C GetProfileIntW PROTO :DWORD,:DWORD,:DWORD
			      C GetProfileSectionA PROTO :DWORD,:DWORD,:DWORD
 = GetProfileSectionA	      C GetProfileSection equ <GetProfileSectionA>
			      C 
			      C GetProfileSectionW PROTO :DWORD,:DWORD,:DWORD
			      C GetProfileStringA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetProfileStringA	      C GetProfileString equ <GetProfileStringA>
			      C 
			      C GetProfileStringW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetQueuedCompletionStatus PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetShortPathNameA PROTO :DWORD,:DWORD,:DWORD
 = GetShortPathNameA	      C GetShortPathName equ <GetShortPathNameA>
			      C 
			      C GetShortPathNameW PROTO :DWORD,:DWORD,:DWORD
			      C GetStartupInfoA PROTO :DWORD
 = GetStartupInfoA	      C GetStartupInfo equ <GetStartupInfoA>
			      C 
			      C GetStartupInfoW PROTO :DWORD
			      C GetStdHandle PROTO :DWORD
			      C GetStringTypeA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetStringTypeA	      C GetStringType equ <GetStringTypeA>
			      C 
			      C GetStringTypeExA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetStringTypeExA	      C GetStringTypeEx equ <GetStringTypeExA>
			      C 
			      C GetStringTypeExW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetStringTypeW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetSystemDefaultLCID PROTO 
			      C GetSystemDefaultLangID PROTO 
			      C GetSystemDefaultUILanguage PROTO 
			      C GetSystemDirectoryA PROTO :DWORD,:DWORD
 = GetSystemDirectoryA	      C GetSystemDirectory equ <GetSystemDirectoryA>
			      C 
			      C GetSystemDirectoryW PROTO :DWORD,:DWORD
			      C GetSystemInfo PROTO :DWORD
			      C GetSystemPowerStatus PROTO :DWORD
			      C GetSystemTime PROTO :DWORD
			      C GetSystemTimeAdjustment PROTO :DWORD,:DWORD,:DWORD
			      C GetSystemTimeAsFileTime PROTO :DWORD
			      C GetSystemWindowsDirectoryA PROTO :DWORD,:DWORD
 = GetSystemWindowsDirector   C GetSystemWindowsDirectory equ <GetSystemWindowsDirectoryA>
   yA
			      C 
			      C GetSystemWindowsDirectoryW PROTO :DWORD,:DWORD
			      C GetTapeParameters PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetTapePosition PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetTapeStatus PROTO :DWORD
			      C GetTempFileNameA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = GetTempFileNameA	      C GetTempFileName equ <GetTempFileNameA>
			      C 
			      C GetTempFileNameW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C GetTempPathA PROTO :DWORD,:DWORD
 = GetTempPathA		      C GetTempPath equ <GetTempPathA>
			      C 
			      C GetTempPathW PROTO :DWORD,:DWORD
			      C GetThreadContext PROTO :DWORD,:DWORD
			      C GetThreadLocale PROTO 
			      C GetThreadPriority PROTO :DWORD
			      C GetThreadPriorityBoost PROTO :DWORD,:DWORD
			      C GetThreadSelectorEntry PROTO :DWORD,:DWORD,:DWORD
			      C GetThreadTimes PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetTickCount PROTO 
			      C GetTimeFormatA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetTimeFormatA	      C GetTimeFormat equ <GetTimeFormatA>
			      C 
			      C GetTimeFormatW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetTimeZoneInformation PROTO :DWORD
			      C GetUserDefaultLCID PROTO 
			      C GetUserDefaultLangID PROTO 
			      C GetUserDefaultUILanguage PROTO 
			      C GetVersion PROTO 
			      C GetVersionExA PROTO :DWORD
 = GetVersionExA	      C GetVersionEx equ <GetVersionExA>
			      C 
			      C GetVersionExW PROTO :DWORD
			      C GetVolumeInformationA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = GetVolumeInformationA      C GetVolumeInformation equ <GetVolumeInformationA>
			      C 
			      C GetVolumeInformationW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GetVolumeNameForVolumeMountPointA PROTO :DWORD,:DWORD,:DWORD
 = GetVolumeNameForVolumeMo   C GetVolumeNameForVolumeMountPoint equ <GetVolumeNameForVolumeMountPointA>
   untPointA
			      C 
			      C GetVolumeNameForVolumeMountPointW PROTO :DWORD,:DWORD,:DWORD
			      C GetVolumePathNameA PROTO :DWORD,:DWORD,:DWORD
 = GetVolumePathNameA	      C GetVolumePathName equ <GetVolumePathNameA>
			      C 
			      C GetVolumePathNameW PROTO :DWORD,:DWORD,:DWORD
			      C GetWindowsDirectoryA PROTO :DWORD,:DWORD
 = GetWindowsDirectoryA	      C GetWindowsDirectory equ <GetWindowsDirectoryA>
			      C 
			      C GetWindowsDirectoryW PROTO :DWORD,:DWORD
			      C GetWriteWatch PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C GlobalAddAtomA PROTO :DWORD
 = GlobalAddAtomA	      C GlobalAddAtom equ <GlobalAddAtomA>
			      C 
			      C GlobalAddAtomW PROTO :DWORD
			      C GlobalAlloc PROTO :DWORD,:DWORD
			      C GlobalCompact PROTO :DWORD
			      C GlobalDeleteAtom PROTO :DWORD
			      C GlobalFindAtomA PROTO :DWORD
 = GlobalFindAtomA	      C GlobalFindAtom equ <GlobalFindAtomA>
			      C 
			      C GlobalFindAtomW PROTO :DWORD
			      C GlobalFix PROTO :DWORD
			      C GlobalFlags PROTO :DWORD
			      C GlobalFree PROTO :DWORD
			      C GlobalGetAtomNameA PROTO :DWORD,:DWORD,:DWORD
 = GlobalGetAtomNameA	      C GlobalGetAtomName equ <GlobalGetAtomNameA>
			      C 
			      C GlobalGetAtomNameW PROTO :DWORD,:DWORD,:DWORD
			      C GlobalHandle PROTO :DWORD
			      C GlobalLock PROTO :DWORD
			      C GlobalMemoryStatus PROTO :DWORD
			      C GlobalMemoryStatusEx PROTO :DWORD
			      C GlobalReAlloc PROTO :DWORD,:DWORD,:DWORD
			      C GlobalSize PROTO :DWORD
			      C GlobalUnWire PROTO :DWORD
			      C GlobalUnfix PROTO :DWORD
			      C GlobalUnlock PROTO :DWORD
			      C GlobalWire PROTO :DWORD
			      C Heap32First PROTO :DWORD,:DWORD,:DWORD
			      C Heap32ListFirst PROTO :DWORD,:DWORD
			      C Heap32ListNext PROTO :DWORD,:DWORD
			      C Heap32Next PROTO :DWORD
			      C HeapAlloc PROTO :DWORD,:DWORD,:DWORD
			      C HeapCompact PROTO :DWORD,:DWORD
			      C HeapCreate PROTO :DWORD,:DWORD,:DWORD
			      C HeapDestroy PROTO :DWORD
			      C HeapFree PROTO :DWORD,:DWORD,:DWORD
			      C HeapLock PROTO :DWORD
			      C HeapReAlloc PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C HeapSize PROTO :DWORD,:DWORD,:DWORD
			      C HeapUnlock PROTO :DWORD
			      C HeapValidate PROTO :DWORD,:DWORD,:DWORD
			      C HeapWalk PROTO :DWORD,:DWORD
			      C InitAtomTable PROTO :DWORD
			      C InitializeCriticalSection PROTO :DWORD
			      C InitializeCriticalSectionAndSpinCount PROTO :DWORD,:DWORD
			      C InterlockedCompareExchange PROTO :DWORD,:DWORD,:DWORD
			      C InterlockedDecrement PROTO :DWORD
			      C InterlockedExchange PROTO :DWORD,:DWORD
			      C InterlockedExchangeAdd PROTO :DWORD,:DWORD
			      C InterlockedIncrement PROTO :DWORD
			      C IsBadCodePtr PROTO :DWORD
			      C IsBadHugeReadPtr PROTO :DWORD,:DWORD
			      C IsBadHugeWritePtr PROTO :DWORD,:DWORD
			      C IsBadReadPtr PROTO :DWORD,:DWORD
			      C IsBadStringPtrA PROTO :DWORD,:DWORD
 = IsBadStringPtrA	      C IsBadStringPtr equ <IsBadStringPtrA>
			      C 
			      C IsBadStringPtrW PROTO :DWORD,:DWORD
			      C IsBadWritePtr PROTO :DWORD,:DWORD
			      C IsDBCSLeadByte PROTO :DWORD
			      C IsDBCSLeadByteEx PROTO :DWORD,:DWORD
			      C IsDebuggerPresent PROTO 
			      C IsProcessorFeaturePresent PROTO :DWORD
			      C IsSystemResumeAutomatic PROTO 
			      C IsValidCodePage PROTO :DWORD
			      C IsValidLanguageGroup PROTO :DWORD,:DWORD
			      C IsValidLocale PROTO :DWORD,:DWORD
			      C LCMapStringA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = LCMapStringA		      C LCMapString equ <LCMapStringA>
			      C 
			      C LCMapStringW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C LeaveCriticalSection PROTO :DWORD
			      C LoadLibraryA PROTO :DWORD
 = LoadLibraryA		      C LoadLibrary equ <LoadLibraryA>
			      C 
			      C LoadLibraryExA PROTO :DWORD,:DWORD,:DWORD
 = LoadLibraryExA	      C LoadLibraryEx equ <LoadLibraryExA>
			      C 
			      C LoadLibraryExW PROTO :DWORD,:DWORD,:DWORD
			      C LoadLibraryW PROTO :DWORD
			      C LoadModule PROTO :DWORD,:DWORD
			      C LoadResource PROTO :DWORD,:DWORD
			      C LocalAlloc PROTO :DWORD,:DWORD
			      C LocalCompact PROTO :DWORD
			      C LocalFileTimeToFileTime PROTO :DWORD,:DWORD
			      C LocalFlags PROTO :DWORD
			      C LocalFree PROTO :DWORD
			      C LocalHandle PROTO :DWORD
			      C LocalLock PROTO :DWORD
			      C LocalReAlloc PROTO :DWORD,:DWORD,:DWORD
			      C LocalShrink PROTO :DWORD,:DWORD
			      C LocalSize PROTO :DWORD
			      C LocalUnlock PROTO :DWORD
			      C LockFile PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C LockFileEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C LockResource PROTO :DWORD
			      C MapUserPhysicalPages PROTO :DWORD,:DWORD,:DWORD
			      C MapUserPhysicalPagesScatter PROTO :DWORD,:DWORD,:DWORD
			      C MapViewOfFile PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C MapViewOfFileEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C Module32First PROTO :DWORD,:DWORD
			      C Module32FirstW PROTO :DWORD,:DWORD
			      C Module32Next PROTO :DWORD,:DWORD
			      C Module32NextW PROTO :DWORD,:DWORD
			      C MoveFileA PROTO :DWORD,:DWORD
 = MoveFileA		      C MoveFile equ <MoveFileA>
			      C 
			      C MoveFileExA PROTO :DWORD,:DWORD,:DWORD
 = MoveFileExA		      C MoveFileEx equ <MoveFileExA>
			      C 
			      C MoveFileExW PROTO :DWORD,:DWORD,:DWORD
			      C MoveFileW PROTO :DWORD,:DWORD
			      C MoveFileWithProgressA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = MoveFileWithProgressA      C MoveFileWithProgress equ <MoveFileWithProgressA>
			      C 
			      C MoveFileWithProgressW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C MulDiv PROTO :DWORD,:DWORD,:DWORD
			      C MultiByteToWideChar PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C OpenEventA PROTO :DWORD,:DWORD,:DWORD
 = OpenEventA		      C OpenEvent equ <OpenEventA>
			      C 
			      C OpenEventW PROTO :DWORD,:DWORD,:DWORD
			      C OpenFile PROTO :DWORD,:DWORD,:DWORD
			      C OpenFileMappingA PROTO :DWORD,:DWORD,:DWORD
 = OpenFileMappingA	      C OpenFileMapping equ <OpenFileMappingA>
			      C 
			      C OpenFileMappingW PROTO :DWORD,:DWORD,:DWORD
			      C OpenJobObjectA PROTO :DWORD,:DWORD,:DWORD
 = OpenJobObjectA	      C OpenJobObject equ <OpenJobObjectA>
			      C 
			      C OpenJobObjectW PROTO :DWORD,:DWORD,:DWORD
			      C OpenMutexA PROTO :DWORD,:DWORD,:DWORD
 = OpenMutexA		      C OpenMutex equ <OpenMutexA>
			      C 
			      C OpenMutexW PROTO :DWORD,:DWORD,:DWORD
			      C OpenProcess PROTO :DWORD,:DWORD,:DWORD
			      C OpenSemaphoreA PROTO :DWORD,:DWORD,:DWORD
 = OpenSemaphoreA	      C OpenSemaphore equ <OpenSemaphoreA>
			      C 
			      C OpenSemaphoreW PROTO :DWORD,:DWORD,:DWORD
			      C OpenThread PROTO :DWORD,:DWORD,:DWORD
			      C OpenWaitableTimerA PROTO :DWORD,:DWORD,:DWORD
 = OpenWaitableTimerA	      C OpenWaitableTimer equ <OpenWaitableTimerA>
			      C 
			      C OpenWaitableTimerW PROTO :DWORD,:DWORD,:DWORD
			      C OutputDebugStringA PROTO :DWORD
 = OutputDebugStringA	      C OutputDebugString equ <OutputDebugStringA>
			      C 
			      C OutputDebugStringW PROTO :DWORD
			      C PeekConsoleInputA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = PeekConsoleInputA	      C PeekConsoleInput equ <PeekConsoleInputA>
			      C 
			      C PeekConsoleInputW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C PeekNamedPipe PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C PostQueuedCompletionStatus PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C PrepareTape PROTO :DWORD,:DWORD,:DWORD
			      C Process32First PROTO :DWORD,:DWORD
			      C Process32FirstW PROTO :DWORD,:DWORD
			      C Process32Next PROTO :DWORD,:DWORD
			      C Process32NextW PROTO :DWORD,:DWORD
			      C ProcessIdToSessionId PROTO :DWORD,:DWORD
			      C PulseEvent PROTO :DWORD
			      C PurgeComm PROTO :DWORD,:DWORD
			      C QueryDosDeviceA PROTO :DWORD,:DWORD,:DWORD
 = QueryDosDeviceA	      C QueryDosDevice equ <QueryDosDeviceA>
			      C 
			      C QueryDosDeviceW PROTO :DWORD,:DWORD,:DWORD
			      C QueryInformationJobObject PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C QueryPerformanceCounter PROTO :DWORD
			      C QueryPerformanceFrequency PROTO :DWORD
			      C QueueUserAPC PROTO :DWORD,:DWORD,:DWORD
			      C QueueUserWorkItem PROTO :DWORD,:DWORD,:DWORD
			      C RaiseException PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C ReadConsoleA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = ReadConsoleA		      C ReadConsole equ <ReadConsoleA>
			      C 
			      C ReadConsoleInputA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = ReadConsoleInputA	      C ReadConsoleInput equ <ReadConsoleInputA>
			      C 
			      C ReadConsoleInputW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C ReadConsoleOutputA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = ReadConsoleOutputA	      C ReadConsoleOutput equ <ReadConsoleOutputA>
			      C 
			      C ReadConsoleOutputAttribute PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadConsoleOutputCharacterA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = ReadConsoleOutputCharact   C ReadConsoleOutputCharacter equ <ReadConsoleOutputCharacterA>
   erA
			      C 
			      C ReadConsoleOutputCharacterW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadConsoleOutputW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadConsoleW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadDirectoryChangesW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadFile PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadFileEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadFileScatter PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReadProcessMemory PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C RegisterWaitForSingleObject PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C RegisterWaitForSingleObjectEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C ReleaseMutex PROTO :DWORD
			      C ReleaseSemaphore PROTO :DWORD,:DWORD,:DWORD
			      C RemoveDirectoryA PROTO :DWORD
 = RemoveDirectoryA	      C RemoveDirectory equ <RemoveDirectoryA>
			      C 
			      C RemoveDirectoryW PROTO :DWORD
			      C ReplaceFileA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = ReplaceFileA		      C ReplaceFile equ <ReplaceFileA>
			      C 
			      C ReplaceFileW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C RequestDeviceWakeup PROTO :DWORD
			      C RequestWakeupLatency PROTO :DWORD
			      C ResetEvent PROTO :DWORD
			      C ResetWriteWatch PROTO :DWORD,:DWORD
			      C ResumeThread PROTO :DWORD
			      C RtlFillMemory PROTO :DWORD,:DWORD,:DWORD
			      C RtlMoveMemory PROTO :DWORD,:DWORD,:DWORD
			      C RtlUnwind PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C RtlZeroMemory PROTO :DWORD,:DWORD
			      C ScrollConsoleScreenBufferA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = ScrollConsoleScreenBuffe   C ScrollConsoleScreenBuffer equ <ScrollConsoleScreenBufferA>
   rA
			      C 
			      C ScrollConsoleScreenBufferW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SearchPathA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = SearchPathA		      C SearchPath equ <SearchPathA>
			      C 
			      C SearchPathW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetCalendarInfoA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = SetCalendarInfoA	      C SetCalendarInfo equ <SetCalendarInfoA>
			      C 
			      C SetCalendarInfoW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C SetCommBreak PROTO :DWORD
			      C SetCommConfig PROTO :DWORD,:DWORD,:DWORD
			      C SetCommMask PROTO :DWORD,:DWORD
			      C SetCommState PROTO :DWORD,:DWORD
			      C SetCommTimeouts PROTO :DWORD,:DWORD
			      C SetComputerNameA PROTO :DWORD
 = SetComputerNameA	      C SetComputerName equ <SetComputerNameA>
			      C 
			      C SetComputerNameExA PROTO :DWORD,:DWORD
 = SetComputerNameExA	      C SetComputerNameEx equ <SetComputerNameExA>
			      C 
			      C SetComputerNameExW PROTO :DWORD,:DWORD
			      C SetComputerNameW PROTO :DWORD
			      C SetConsoleActiveScreenBuffer PROTO :DWORD
			      C SetConsoleCP PROTO :DWORD
			      C SetConsoleCtrlHandler PROTO :DWORD,:DWORD
			      C SetConsoleCursor PROTO :DWORD,:DWORD
			      C SetConsoleCursorInfo PROTO :DWORD,:DWORD
			      C SetConsoleCursorPosition PROTO :DWORD,:DWORD
			      C SetConsoleMode PROTO :DWORD,:DWORD
			      C SetConsoleOutputCP PROTO :DWORD
			      C SetConsoleScreenBufferSize PROTO :DWORD,:DWORD
			      C SetConsoleTextAttribute PROTO :DWORD,:DWORD
			      C SetConsoleTitleA PROTO :DWORD
 = SetConsoleTitleA	      C SetConsoleTitle equ <SetConsoleTitleA>
			      C 
			      C SetConsoleTitleW PROTO :DWORD
			      C SetConsoleWindowInfo PROTO :DWORD,:DWORD,:DWORD
			      C SetCriticalSectionSpinCount PROTO :DWORD,:DWORD
			      C SetCurrentDirectoryA PROTO :DWORD
 = SetCurrentDirectoryA	      C SetCurrentDirectory equ <SetCurrentDirectoryA>
			      C 
			      C SetCurrentDirectoryW PROTO :DWORD
			      C SetDefaultCommConfigA PROTO :DWORD,:DWORD,:DWORD
 = SetDefaultCommConfigA      C SetDefaultCommConfig equ <SetDefaultCommConfigA>
			      C 
			      C SetDefaultCommConfigW PROTO :DWORD,:DWORD,:DWORD
			      C SetEndOfFile PROTO :DWORD
			      C SetEnvironmentVariableA PROTO :DWORD,:DWORD
 = SetEnvironmentVariableA    C SetEnvironmentVariable equ <SetEnvironmentVariableA>
			      C 
			      C SetEnvironmentVariableW PROTO :DWORD,:DWORD
			      C SetErrorMode PROTO :DWORD
			      C SetEvent PROTO :DWORD
			      C SetFileApisToANSI PROTO 
			      C SetFileApisToOEM PROTO 
			      C SetFileAttributesA PROTO :DWORD,:DWORD
 = SetFileAttributesA	      C SetFileAttributes equ <SetFileAttributesA>
			      C 
			      C SetFileAttributesW PROTO :DWORD,:DWORD
			      C SetFilePointer PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C SetFilePointerEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetFileTime PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C SetHandleCount PROTO :DWORD
			      C SetHandleInformation PROTO :DWORD,:DWORD,:DWORD
			      C SetInformationJobObject PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C SetLastError PROTO :DWORD
			      C SetLocalTime PROTO :DWORD
			      C SetLocaleInfoA PROTO :DWORD,:DWORD,:DWORD
 = SetLocaleInfoA	      C SetLocaleInfo equ <SetLocaleInfoA>
			      C 
			      C SetLocaleInfoW PROTO :DWORD,:DWORD,:DWORD
			      C SetMailslotInfo PROTO :DWORD,:DWORD
			      C SetMessageWaitingIndicator PROTO :DWORD,:DWORD
			      C SetNamedPipeHandleState PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C SetPriorityClass PROTO :DWORD,:DWORD
			      C SetProcessAffinityMask PROTO :DWORD,:DWORD
			      C SetProcessPriorityBoost PROTO :DWORD,:DWORD
			      C SetProcessShutdownParameters PROTO :DWORD,:DWORD
			      C SetProcessWorkingSetSize PROTO :DWORD,:DWORD,:DWORD
			      C SetStdHandle PROTO :DWORD,:DWORD
			      C SetSystemPowerState PROTO :DWORD,:DWORD
			      C SetSystemTime PROTO :DWORD
			      C SetSystemTimeAdjustment PROTO :DWORD,:DWORD
			      C SetTapeParameters PROTO :DWORD,:DWORD,:DWORD
			      C SetTapePosition PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetThreadAffinityMask PROTO :DWORD,:DWORD
			      C SetThreadContext PROTO :DWORD,:DWORD
			      C SetThreadExecutionState PROTO :DWORD
			      C SetThreadIdealProcessor PROTO :DWORD,:DWORD
			      C SetThreadLocale PROTO :DWORD
			      C SetThreadPriority PROTO :DWORD,:DWORD
			      C SetThreadPriorityBoost PROTO :DWORD,:DWORD
			      C SetTimeZoneInformation PROTO :DWORD
			      C SetTimerQueueTimer PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetUnhandledExceptionFilter PROTO :DWORD
			      C SetVolumeLabelA PROTO :DWORD,:DWORD
 = SetVolumeLabelA	      C SetVolumeLabel equ <SetVolumeLabelA>
			      C 
			      C SetVolumeLabelW PROTO :DWORD,:DWORD
			      C SetVolumeMountPointA PROTO :DWORD,:DWORD
 = SetVolumeMountPointA	      C SetVolumeMountPoint equ <SetVolumeMountPointA>
			      C 
			      C SetVolumeMountPointW PROTO :DWORD,:DWORD
			      C SetWaitableTimer PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C SetupComm PROTO :DWORD,:DWORD,:DWORD
			      C SignalObjectAndWait PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C SizeofResource PROTO :DWORD,:DWORD
			      C Sleep PROTO :DWORD
			      C SleepEx PROTO :DWORD,:DWORD
			      C SuspendThread PROTO :DWORD
			      C SwitchToFiber PROTO :DWORD
			      C SwitchToThread PROTO 
			      C SystemTimeToFileTime PROTO :DWORD,:DWORD
			      C SystemTimeToTzSpecificLocalTime PROTO :DWORD,:DWORD,:DWORD
			      C TerminateJobObject PROTO :DWORD,:DWORD
			      C TerminateProcess PROTO :DWORD,:DWORD
			      C TerminateThread PROTO :DWORD,:DWORD
			      C Thread32First PROTO :DWORD,:DWORD
			      C Thread32Next PROTO :DWORD,:DWORD
			      C TlsAlloc PROTO 
			      C TlsFree PROTO :DWORD
			      C TlsGetValue PROTO :DWORD
			      C TlsSetValue PROTO :DWORD,:DWORD
			      C Toolhelp32ReadProcessMemory PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C TransactNamedPipe PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C TransmitCommChar PROTO :DWORD,:DWORD
			      C TryEnterCriticalSection PROTO :DWORD
			      C UnhandledExceptionFilter PROTO :DWORD
			      C UnlockFile PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C UnlockFileEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C UnmapViewOfFile PROTO :DWORD
			      C UnregisterWait PROTO :DWORD
			      C UnregisterWaitEx PROTO :DWORD,:DWORD
			      C UpdateResourceA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = UpdateResourceA	      C UpdateResource equ <UpdateResourceA>
			      C 
			      C UpdateResourceW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C VerLanguageNameA PROTO :DWORD,:DWORD,:DWORD
 = VerLanguageNameA	      C VerLanguageName equ <VerLanguageNameA>
			      C 
			      C VerLanguageNameW PROTO :DWORD,:DWORD,:DWORD
			      C VerSetConditionMask PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C VerifyVersionInfoA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = VerifyVersionInfoA	      C VerifyVersionInfo equ <VerifyVersionInfoA>
			      C 
			      C VerifyVersionInfoW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualAlloc PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualAllocEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualFree PROTO :DWORD,:DWORD,:DWORD
			      C VirtualFreeEx PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualLock PROTO :DWORD,:DWORD
			      C VirtualProtect PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualProtectEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualQuery PROTO :DWORD,:DWORD,:DWORD
			      C VirtualQueryEx PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C VirtualUnlock PROTO :DWORD,:DWORD
			      C WaitCommEvent PROTO :DWORD,:DWORD,:DWORD
			      C WaitForDebugEvent PROTO :DWORD,:DWORD
			      C WaitForMultipleObjects PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C WaitForMultipleObjectsEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WaitForSingleObject PROTO :DWORD,:DWORD
			      C WaitForSingleObjectEx PROTO :DWORD,:DWORD,:DWORD
			      C WaitNamedPipeA PROTO :DWORD,:DWORD
 = WaitNamedPipeA	      C WaitNamedPipe equ <WaitNamedPipeA>
			      C 
			      C WaitNamedPipeW PROTO :DWORD,:DWORD
			      C WideCharToMultiByte PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WinExec PROTO :DWORD,:DWORD
			      C WriteConsoleA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = WriteConsoleA	      C WriteConsole equ <WriteConsoleA>
			      C 
			      C WriteConsoleInputA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = WriteConsoleInputA	      C WriteConsoleInput equ <WriteConsoleInputA>
			      C 
			      C WriteConsoleInputW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C WriteConsoleOutputA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = WriteConsoleOutputA	      C WriteConsoleOutput equ <WriteConsoleOutputA>
			      C 
			      C WriteConsoleOutputAttribute PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteConsoleOutputCharacterA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = WriteConsoleOutputCharac   C WriteConsoleOutputCharacter equ <WriteConsoleOutputCharacterA>
   terA
			      C 
			      C WriteConsoleOutputCharacterW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteConsoleOutputW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteConsoleW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteFile PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteFileEx PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteFileGather PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WritePrivateProfileSectionA PROTO :DWORD,:DWORD,:DWORD
 = WritePrivateProfileSecti   C WritePrivateProfileSection equ <WritePrivateProfileSectionA>
   onA
			      C 
			      C WritePrivateProfileSectionW PROTO :DWORD,:DWORD,:DWORD
			      C WritePrivateProfileStringA PROTO :DWORD,:DWORD,:DWORD,:DWORD
 = WritePrivateProfileStrin   C WritePrivateProfileString equ <WritePrivateProfileStringA>
   gA
			      C 
			      C WritePrivateProfileStringW PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C WritePrivateProfileStructA PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
 = WritePrivateProfileStruc   C WritePrivateProfileStruct equ <WritePrivateProfileStructA>
   tA
			      C 
			      C WritePrivateProfileStructW PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteProcessMemory PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
			      C WriteProfileSectionA PROTO :DWORD,:DWORD
 = WriteProfileSectionA	      C WriteProfileSection equ <WriteProfileSectionA>
			      C 
			      C WriteProfileSectionW PROTO :DWORD,:DWORD
			      C WriteProfileStringA PROTO :DWORD,:DWORD,:DWORD
 = WriteProfileStringA	      C WriteProfileString equ <WriteProfileStringA>
			      C 
			      C WriteProfileStringW PROTO :DWORD,:DWORD,:DWORD
			      C WriteTapemark PROTO :DWORD,:DWORD,:DWORD,:DWORD
			      C _hread PROTO :DWORD,:DWORD,:DWORD
			      C _hwrite PROTO :DWORD,:DWORD,:DWORD
			      C _lclose PROTO :DWORD
			      C _lcreat PROTO :DWORD,:DWORD
			      C _llseek PROTO :DWORD,:DWORD,:DWORD
			      C _lopen PROTO :DWORD,:DWORD
			      C _lread PROTO :DWORD,:DWORD,:DWORD
			      C _lwrite PROTO :DWORD,:DWORD,:DWORD
			      C lstrcatA PROTO :DWORD,:DWORD
 = lstrcatA		      C lstrcat equ <lstrcatA>
			      C 
			      C lstrcatW PROTO :DWORD,:DWORD
			      C lstrcmpA PROTO :DWORD,:DWORD
 = lstrcmpA		      C lstrcmp equ <lstrcmpA>
			      C 
			      C lstrcmpW PROTO :DWORD,:DWORD
			      C lstrcmpiA PROTO :DWORD,:DWORD
 = lstrcmpiA		      C lstrcmpi equ <lstrcmpiA>
			      C 
			      C lstrcmpiW PROTO :DWORD,:DWORD
			      C lstrcpyA PROTO :DWORD,:DWORD
 = lstrcpyA		      C lstrcpy equ <lstrcpyA>
			      C 
			      C lstrcpyW PROTO :DWORD,:DWORD
			      C lstrcpynA PROTO :DWORD,:DWORD,:DWORD
 = lstrcpynA		      C lstrcpyn equ <lstrcpynA>
			      C 
			      C lstrcpynW PROTO :DWORD,:DWORD,:DWORD
			      C lstrlenA PROTO :DWORD
 = lstrlenA		      C lstrlen equ <lstrlenA>
			      C 
			      C lstrlenW PROTO :DWORD
			      C 
				    include macros.asm
			      C comment й -----------------------------------------------------------------
			      C                           Support macros for MASM32
			      C 
			      C                           Updated 4th December 2003
			      C          ---------------------------------------------------------------- й
			      C 
			      C comment * -----------------------------------------------------------------
			      C 
			      C    NOTES on DDPROTO macro
			      C 
			      C    This macro is for producing prototypes for functions where the start
			      C    address is known and the parameter count is known. It requires a named
			      C    DWORD sized entry in the .DATA or .DATA? section which has the start
			      C    address written to it before the function is called.
			      C 
			      C         EXAMPLE:
			      C         .data?
			      C           user32_msgbox dd ?            ; << The named variable
			      C 
			      C         msgbox DDPROTO(user32_msgbox,4) ; create prototype
			      C 
			      C         This is expanded to the following. The TYPEDEF refers to
			      C         the macro "pr4" in the WINDOWS.INC file.
			      C 
			      C         pt4 TYPEDEF PTR pr4
			      C         msgbox equ <(TYPE pt4) PTR user32_msgbox>
			      C 
			      C         The address must be written to the DWORD variable before it can
			      C         be called. This can be LoadLibrary/GetProcAddress or it can be
			      C         an address recovered from a virtual table in a DLL or any other
			      C         viable means of obtaining the start address of a function to call.
			      C 
			      C         invoke msgbox,hWnd,ADDR message_text, ADDR title_text,MB_OK
			      C 
			      C         ----------------------------------------------------------------- *
			      C 
			      C       DDPROTO MACRO lpFunction,pcount
			      C         LOCAL txt1,txt2
			      C         txt1 equ <pr>
			      C         txt1 CATSTR txt1,%pcount
			      C         txt2 equ <pt>
			      C         txt2 CATSTR txt2,%pcount
			      C         txt2 TYPEDEF PTR txt1
			      C         EXITM <equ <(TYPE txt2) PTR lpFunction>>
			      C       ENDM
			      C 
			      C   ; -----------------------------------------------------------
			      C   ; This macro replaces quoted text with a DATA section OFFSET
			      C   ; and returns it in ADDR "name" format. It is used by other
			      C   ; macros that handle optional quoted text as a parameter.
			      C   ; -----------------------------------------------------------
			      C     reparg MACRO arg
			      C       LOCAL nustr
			      C         quot SUBSTR <arg>,1,1
			      C       IFIDN quot,<">            ;; if 1st char = "
			      C         .data
			      C           nustr db arg,0        ;; write arg to .DATA section
			      C         .code
			      C         EXITM <ADDR nustr>      ;; append name to ADDR operator
			      C       ELSE
			      C         EXITM <arg>             ;; else return arg
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; -------------------------------------------------------
			      C   ; This is a parameter checking macro. It is used to test
			      C   ; if a parameter in a macro is a quoted string when a
			      C   ; quoted string should not be used as a parameter. If it
			      C   ; is a user defined error message is displayed at
			      C   ; assembly time so that the error can be fixed.
			      C   ; -------------------------------------------------------
			      C     tstarg MACRO arg
			      C       quot SUBSTR <arg>,1,1
			      C       IFIDN quot,<">            ;; if 1st char = "
			      C         % echo arg ** QUOTED TEXT ERROR ** memory address expected
			      C         .ERR
			      C       ELSE
			      C         EXITM <arg>             ;; else return arg
			      C       ENDIF
			      C     ENDM
			      C 
			      C   ; ----------------------------------------------------------------
			      C   ; invoke enhancement. Add quoted text support to any procedure
			      C   ; or API call by using this macro instead of the standard invoke.
			      C   ; LIMITATION : quoted text must be plain text only, no ascii 
			      C   ; values or macro reserved characters IE <>!() etc ..
			      C   ; use SADD() for requirements of this type.
			      C   ; ----------------------------------------------------------------
			      C     fn MACRO args:VARARG
			      C       LOCAL cnt
			      C       cnt = 0
			      C       arg equ <>
			      C       FOR var,<args>
			      C         arg CATSTR arg,<var> ;; get the proc name as 1st arg
			      C         EXITM
			      C       ENDM
			      C       FOR var,<args>
			      C         IF cnt gt 0
			      C         arg CATSTR arg,<,reparg(var)> ;; replace quotes and append arg
			      C         ENDIF
			      C         cnt = cnt + 1
			      C       ENDM
			      C       invoke arg
			      C     ENDM
			      C 
			      C     ; *******************
			      C     ; DATA DECLARATIONS *
			      C     ; *******************
			      C 
			      C     ; -------------------------------------
			      C     ; initialised GLOBAL value of any type
			      C     ; -------------------------------------
			      C       GLOBAL MACRO variable:VARARG
			      C       .data
			      C       align 4
			      C         variable
			      C       .code
			      C       ENDM
			      C 
			      C     ; --------------------------------
			      C     ; initialised GLOBAL string value
			      C     ; --------------------------------
			      C       STRING MACRO variable:REQ,args:VARARG
			      C       .data
			      C         variable db args,0
			      C         align 4
			      C       .code
			      C       ENDM
			      C 
			      C     ; --------------------------------
			      C     ; initialise floating point vaues
			      C     ; --------------------------------
			      C 
			      C       FLOAT4 MACRO name,value
			      C         .data
			      C         align 4
			      C           name REAL4 value
			      C         .code
			      C       ENDM
			      C 
			      C       FLOAT8 MACRO name,value
			      C         .data
			      C         align 4
			      C           name REAL8 value
			      C         .code
			      C       ENDM
			      C 
			      C       FLOAT10 MACRO name,value
			      C         .data
			      C         align 4
			      C           name REAL10 value
			      C         .code
			      C       ENDM
			      C 
			      C     ; **********************************************************
			      C     ; function style macros for direct insertion of data types *
			      C     ; **********************************************************
			      C 
			      C       FP4 MACRO value
			      C         LOCAL vname
			      C         .data
			      C         align 4
			      C           vname REAL4 value
			      C         .code
			      C         EXITM <vname>
			      C       ENDM
			      C 
			      C       FP8 MACRO value
			      C         LOCAL vname
			      C         .data
			      C         align 4
			      C           vname REAL8 value
			      C         .code
			      C         EXITM <vname>
			      C       ENDM
			      C 
			      C       FP10 MACRO value
			      C         LOCAL vname
			      C         .data
			      C         align 4
			      C           vname REAL10 value
			      C         .code
			      C         EXITM <vname>
			      C       ENDM
			      C 
			      C     ; **********************************************
			      C     ; The original concept for the following macro *
			      C     ; was designed by "huh" from New Zealand.      *
			      C     ; **********************************************
			      C 
			      C     ; ---------------------
			      C     ; literal string MACRO
			      C     ; ---------------------
			      C       literal MACRO quoted_text:VARARG
			      C         LOCAL local_text
			      C         .data
			      C           local_text db quoted_text,0
			      C         align 4
			      C         .code
			      C         EXITM <local_text>
			      C       ENDM
			      C     ; --------------------------------
			      C     ; string address in INVOKE format
			      C     ; --------------------------------
			      C       SADD MACRO quoted_text:VARARG
			      C         EXITM <ADDR literal(quoted_text)>
			      C       ENDM
			      C     ; --------------------------------
			      C     ; string OFFSET for manual coding
			      C     ; --------------------------------
			      C       CTXT MACRO quoted_text:VARARG
			      C         EXITM <offset literal(quoted_text)>
			      C       ENDM
			      C 
			      C     ; -----------------------------------------------------
			      C     ; string address embedded directly in the code section
			      C     ; -----------------------------------------------------
			      C       CADD MACRO quoted_text:VARARG
			      C         LOCAL vname,lbl
			      C           jmp lbl
			      C             vname db quoted_text,0
			      C           align 4
			      C           lbl:
			      C         EXITM <ADDR vname>
			      C       ENDM
			      C 
			      C     ; --------------------------------------------------
			      C     ; Macro for placing an assembler instruction either
			      C     ; within another or within a procedure call
			      C     ; --------------------------------------------------
			      C 
			      C     ASM MACRO parameter1,source
			      C       LOCAL mnemonic
			      C       LOCAL dest
			      C       LOCAL poz
			      C 
			      C       % poz INSTR 1,<parameter1>,< >             ;; get the space position
			      C       mnemonic SUBSTR <parameter1>, 1, poz-1     ;; get the mnemonic
			      C       dest SUBSTR <parameter1>, poz+1            ;; get the first argument
			      C 
			      C       mnemonic dest, source
			      C 
			      C       EXITM <dest>
			      C     ENDM
			      C 
			      C     ; ------------------------------------------------------------
			      C     ; Macro for nesting function calls in other invoke statements
			      C     ; ------------------------------------------------------------
			      C       FUNC MACRO parameters:VARARG
			      C         invoke parameters
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; -------------------------------------------
			      C     ;             Pseudo mnemonics.
			      C     ; These macros emulate assembler mnemonics
			      C     ; but perform higher level operations not
			      C     ; directly supported by the instruction set
			      C     ; NOTE: The parameter order is the normal
			      C     ; assembler order of,
			      C     ; instruction/destination/source
			      C     ; -------------------------------------------
			      C 
			      C     ; --------------------------
			      C     ; szstring to szstring copy
			      C     ; --------------------------
			      C       cst MACRO arg1,arg2
			      C         invoke szCopy,reparg(arg2),tstarg(arg1)
			      C       ENDM
			      C 
			      C     ; ----------------------------
			      C     ; memory to memory assignment
			      C     ; ----------------------------
			      C       m2m MACRO M1, M2
			      C         push M2
			      C         pop  M1
			      C       ENDM
			      C 
			      C     ; **********************************
			      C     ;         String assign.           *
			      C     ; Assign quoted text and assembler *
			      C     ; notation to a DWORD variable     *
			      C     ; sas var,"text",13,10,"more",0    *
			      C     ; NOTE: zero is always appended    *
			      C     ; **********************************
			      C 
			      C       sas MACRO var,quoted_text:VARARG
			      C         LOCAL txtname
			      C         .data
			      C           txtname db quoted_text,0
			      C           align 4
			      C         .code
			      C         mov var, OFFSET txtname
			      C       ENDM
			      C 
			      C     ; --------------------------------------------
			      C     ; emulation of the floating point mnemonic FLD
			      C     ; to load real4/8/10 values
			      C     ; EXAMPLE : fld8 1234.56789
			      C     ; --------------------------------------------
			      C       fld4 MACRO fpvalue
			      C         LOCAL name
			      C         .data
			      C           name REAL4 fpvalue
			      C           align 4
			      C         .code
			      C         fld name
			      C       ENDM
			      C 
			      C       fld8 MACRO fpvalue
			      C         LOCAL name
			      C         .data
			      C           name REAL8 fpvalue
			      C           align 4
			      C         .code
			      C         fld name
			      C       ENDM
			      C 
			      C       fld10 MACRO fpvalue
			      C         LOCAL name
			      C         .data
			      C           name REAL10 fpvalue
			      C           align 4
			      C         .code
			      C         fld name
			      C       ENDM
			      C     ; --------------------------------------------
			      C 
			      C   ; ----------------------------------------------------------
			      C   ; function position macros that takes a DWORD parameter and
			      C   ; returns the address of the buffer that holds the result.
			      C   ; The return format is for use within the INVOKE syntax.
			      C   ; ----------------------------------------------------------
			      C     str$ MACRO DDvalue
			      C       LOCAL rvstring
			      C       .data
			      C         rvstring db 20 dup (0)
			      C         align 4
			      C       .code
			      C       invoke dwtoa,DDvalue,ADDR rvstring
			      C       EXITM <ADDR rvstring>
			      C     ENDM
			      C 
			      C     hex$ MACRO DDvalue
			      C       LOCAL rvstring
			      C       .data
			      C         rvstring db 12 dup (0)
			      C         align 4
			      C       .code
			      C       invoke dw2hex,DDvalue,ADDR rvstring
			      C       EXITM <ADDR rvstring>
			      C     ENDM
			      C 
			      C     ; ******************************************************
			      C     ; BASIC style conversions from string to 32 bit integer
			      C     ; ******************************************************
			      C       sval MACRO lpstring       ; string to signed 32 bit integer
			      C         invoke atol, reparg(lpstring)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       uval MACRO lpstring       ; string to unsigned 32 bit integer
			      C         invoke atodw, reparg(lpstring)
			      C         EXITM <eax>
			      C       ENDM
			      C 
 = uval			      C       val equ <uval>
			      C 
			      C       hval MACRO lpstring       ; hex string to unsigned 32 bit integer
			      C         invoke htodw, reparg(lpstring)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; ********************************
			      C     ; BASIC string function emulation
			      C     ; ********************************
			      C       add$ MACRO lpSource,lpAppend
			      C         invoke szCatStr,tstarg(lpSource),reparg(lpAppend)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       append$ MACRO string,buffer,location
			      C         invoke szappend,reparg(string),buffer,location
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       chr$ MACRO any_text:VARARG
			      C         LOCAL txtname
			      C         .data
			      C           txtname db any_text,0
			      C         .code
			      C         EXITM <OFFSET txtname>
			      C       ENDM
			      C 
			      C       ptr$ MACRO buffer
			      C         lea eax, buffer
			      C         mov BYTE PTR [eax], 0
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       len MACRO lpString
			      C         invoke szLen,reparg(lpString)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       istring MACRO spos,lpMainString,lpSubString
			      C         invoke InString,spos,reparg(lpMainString),reparg(lpSubString)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       ucase$ MACRO lpString
			      C         invoke szUpper,reparg(lpString)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       lcase$ MACRO lpString
			      C         invoke szLower,reparg(lpString)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       left$ MACRO lpString,slen
			      C         invoke szLeft,reparg(lpString),reparg(lpString),slen
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       right$ MACRO lpString,slen
			      C         invoke szRight,reparg(lpString),reparg(lpString),slen
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       rev$ MACRO lpString
			      C         invoke szRev,reparg(lpString),reparg(lpString)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       ltrim$ MACRO lpString
			      C         invoke szLtrim,reparg(lpString),reparg(lpString)
			      C         mov eax, ecx
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       rtrim$ MACRO lpString
			      C         invoke szRtrim,reparg(lpString),reparg(lpString)
			      C         mov eax, ecx
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       trim$ MACRO lpString
			      C         invoke szTrim,reparg(lpString)
			      C         mov eax, ecx
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       remove$ MACRO src,substr
			      C         invoke szRemove,reparg(src),reparg(src),reparg(substr)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       ustr$ MACRO DDvalue   ;; unsigned integer from string
			      C         LOCAL rvstring
			      C         .data
			      C           rvstring db 20 dup (0)
			      C         align 4
			      C         .code
			      C         invoke dwtoa,DDvalue,ADDR rvstring
			      C         EXITM <OFFSET rvstring>
			      C       ENDM
			      C 
			      C       sstr$ MACRO DDvalue   ;; signed integer from string
			      C         LOCAL rvstring
			      C         .data
			      C           rvstring db 20 dup (0)
			      C         align 4
			      C         .code
			      C         invoke ltoa,DDvalue,ADDR rvstring
			      C         EXITM <OFFSET rvstring>
			      C       ENDM
			      C 
			      C       uhex$ MACRO DDvalue   ;; unsigned DWORD to hex string
			      C         LOCAL rvstring
			      C         .data
			      C           rvstring db 12 dup (0)
			      C         align 4
			      C         .code
			      C         invoke dw2hex,DDvalue,ADDR rvstring
			      C         EXITM <OFFSET rvstring>
			      C       ENDM
			      C 
			      C comment * -------------------------------------------------------
			      C         Each of the following macros has its own dedicated 260
			      C         BYTE buffer. The OFFSET returned by each macro can be
			      C         used directly in code but if the macro is called again
			      C         the data in the dedicated buffer will be overwritten
			      C         with the new result.
			      C 
			      C         mov str1, ptr$(buffer)
			      C         mov str2, pth$()
			      C         invoke szCopy str2,str1
			      C 
			      C         Empty brackets should be used with these macros as they
			      C         take no parameters. pth$() CurDir$() etc ...
			      C         ------------------------------------------------------- *
			      C 
			      C       pth$ MACRO            ;; application path OFFSET returned
			      C         IFNDEF pth__equate__flag
			      C         .data?
			      C           pth__260_BYTE__buffer db MAX_PATH dup (?)
			      C         .code
			      C         pth__equate__flag equ <1>
			      C         ENDIF
			      C         invoke GetAppPath,ADDR pth__260_BYTE__buffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       CurDir$ MACRO
			      C         IFNDEF cdir__equate__flag
			      C         .data?
			      C           cdir__260_BYTE__buffer db MAX_PATH dup (?)
			      C         .code
			      C         cdir__equate__flag equ <1>
			      C         ENDIF
			      C         invoke GetCurrentDirectory,MAX_PATH,ADDR cdir__260_BYTE__buffer
			      C         mov eax, OFFSET cdir__260_BYTE__buffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       SysDir$ MACRO
			      C         IFNDEF sys__equate__flag
			      C         .data?
			      C           sysdir__260_BYTE__buffer db MAX_PATH dup (?)
			      C         .code
			      C         sys__equate__flag equ <1>
			      C         ENDIF
			      C         invoke GetSystemDirectory,ADDR sysdir__260_BYTE__buffer,MAX_PATH
			      C         mov eax, OFFSET sysdir__260_BYTE__buffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       WinDir$ MACRO
			      C         IFNDEF wdir__equate__flag
			      C         .data?
			      C           windir__260_BYTE__buffer db MAX_PATH dup (?)
			      C         .code
			      C         wdir__equate__flag equ <1>
			      C         ENDIF
			      C         invoke GetWindowsDirectory,ADDR windir__260_BYTE__buffer,MAX_PATH
			      C         mov eax, OFFSET windir__260_BYTE__buffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; ---------------------------------------------------------------
			      C     ; Get command line arg specified by "argnum" starting at arg 1
			      C     ; Test the return values with the following to determine results
			      C     ; 1 = successful operation
			      C     ; 2 = no argument exists at specified arg number
			      C     ; 3 = non matching quotation marks
			      C     ; 4 = empty quotation marks
			      C     ; test the return value in ECX
			      C     ; ---------------------------------------------------------------
			      C       cmd$ MACRO argnum
			      C         LOCAL argbuffer
			      C         IFNDEF cmdflag
			      C         .data?
			      C           argbuffer db MAX_PATH dup (?)
			      C         .code
			      C         cmdflag equ 1
			      C         ENDIF
			      C         invoke GetCL,argnum, ADDR argbuffer
			      C         mov ecx, eax
			      C         mov eax, OFFSET argbuffer
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C   ; ******************************************
			      C   ; DOS style directory manipulation macros  *
			      C   ; The parameters passed to these directory *
			      C   ; macros should be zero terminated string  *
			      C   ; addresses.                               *
			      C   ; ******************************************
			      C       chdir MACRO pathname
			      C         invoke SetCurrentDirectory,reparg(pathname)
			      C       ENDM
 = chdir		      C       CHDIR equ <chdir>
			      C 
			      C       mkdir MACRO dirname
			      C         invoke CreateDirectory,reparg(dirname),NULL
			      C       ENDM
 = mkdir		      C       MKDIR equ <mkdir>
			      C 
			      C       rndir MACRO oldname,newname
			      C         invoke MoveFile,reparg(oldname),reparg(newname)
			      C       ENDM
 = rndir		      C       RNDIR equ <rndir>
			      C 
			      C       rmdir MACRO dirname
			      C         invoke RemoveDirectory,reparg(dirname)
			      C       ENDM
 = rmdir		      C       RMDIR equ <rmdir>
			      C 
			      C     ; **************************
			      C     ; memory allocation macros *
			      C     ; **************************
			      C 
			      C     comment * --------------------------------------------------    
			      C             Two macros for allocating and freeing OLE memory.
			      C             stralloc returns the handle/address of the string
			      C             memory in eax. alloc$ acts in the same way but is
			      C             used in the function position. strfree uses the
			      C             handle to free memory after use.
			      C     
			      C             NOTE that you must use the following INCLUDE &
			      C             LIB files with these two macros.
			      C     
			      C             include \MASM32\include\oleaut32.inc
			      C             includelib \MASM32\LIB\oleaut32.lib
			      C             -------------------------------------------------- *
			      C 
			      C       alloc$ MACRO ln
			      C         invoke SysAllocStringByteLen,0,ln
			      C         mov BYTE PTR [eax], 0
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       free$ MACRO strhandle
			      C         invoke SysFreeString,strhandle
			      C       ENDM
			      C 
			      C       stralloc MACRO ln
			      C         invoke SysAllocStringByteLen,0,ln
			      C       ENDM
			      C 
			      C       strfree MACRO strhandle
			      C         invoke SysFreeString,strhandle
			      C       ENDM
			      C 
			      C comment * ------------------------------------------------
			      C     The following 2 macros are for general purpose memory
			      C     allocation where fine granularity in memory is required
			      C     or where the memory attribute "execute" is useful.
			      C     ------------------------------------------------------ *
			      C 
			      C       alloc MACRO bytecount
			      C         invoke GlobalAlloc,GMEM_FIXED or GMEM_ZEROINIT,bytecount
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       free MACRO hmemory
			      C         invoke GlobalFree,hmemory
			      C       ENDM
			      C 
			      C     ; ************************************************************
			      C     ;                       File IO macros                       *
			      C     ; NOTE: With the address returned by InputFile that contains *
			      C     ; the data in the file, it must be deallocated using the API *
			      C     ; function GlobalFree().                                     *
			      C     ; EXAMPLE: invoke GlobalFree,pMem                            *
			      C     ; ************************************************************
			      C 
			      C       InputFile MACRO lpFile
			      C       ; ----------------------------------------------------------
			      C       ; The untidy data? names are to avoid duplication in normal
			      C       ; code. The two values are reused by each call to the macro
			      C       ; ----------------------------------------------------------
			      C         IFNDEF ipf@@flag            ;; if the flag is not defined
			      C           .data?
			      C             ipf@__@mem@__@Ptr dd ?  ;; write 2 DWORD variables to
			      C             ipf@__file__@len dd ?   ;; the uninitialised data section
			      C           .code
			      C           ipf@@flag equ <1>         ;; define the flag
			      C         ENDIF
			      C         invoke read_disk_file,reparg(lpFile),
			      C                ADDR ipf@__@mem@__@Ptr,
			      C                ADDR ipf@__file__@len
			      C         mov ecx, ipf@__file__@len   ;; file length returned in ECX
			      C         mov eax, ipf@__@mem@__@Ptr  ;; address of memory returned in EAX
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       OutputFile MACRO lpFile,lpMem,lof
			      C         invoke write_disk_file,reparg(lpFile),lpMem,lof
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; -----------------------------------------
			      C     ; common dialog file open and close macros.
			      C     ; Return value in both is the OFFSET of a
			      C     ; 260 byte dedicated buffer in the .DATA?
			      C     ; section in EAX.
			      C     ; -----------------------------------------
			      C       OpenFileDlg MACRO hWin,hInstance,lpTitle,lpPattern
			      C         invoke OpenFileDialog,hWin,hInstance,reparg(lpTitle),reparg(lpPattern)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C       SaveFileDlg MACRO hWin,hInstance,lpTitle,lpPattern
			      C         invoke SaveFileDialog,hWin,hInstance,reparg(lpTitle),reparg(lpPattern)
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; ----------------------------------------------------------
			      C     ; load a library and get the procedure address in one macro
			      C     ; return value for the proc address in in EAX. Both DLL and
			      C     ; procedure name are enclosed in quotation marks.
			      C     ;
			      C     ; EXAMPLE : LoadProcAddress "mydll.dll","myproc"
			      C     ;           proc address in EAX
			      C     ;           library handle in ECX
			      C     ;
			      C     ; EXAMPLE : mov lpProc, GetDllProc("mydll.dll","myproc")
			      C     ;           library handle in ECX
			      C     ;
			      C     ; ----------------------------------------------------------
			      C 
			      C       LoadProcAddress MACRO libname_text1,procname_text2
			      C         LOCAL library_name
			      C         LOCAL proc_name
			      C           .data
			      C             library_name db libname_text1,0
			      C             proc_name db procname_text2,0
			      C           align 4
			      C           .code
			      C         invoke LoadLibrary,ADDR library_name
			      C         mov ecx, eax
			      C         invoke GetProcAddress,eax,ADDR proc_name
			      C       ENDM
			      C 
			      C       GetDllProc MACRO libname_text1,procname_text2
			      C         LOCAL library_name
			      C         LOCAL proc_name
			      C           .data
			      C             library_name db libname_text1,0
			      C             proc_name db procname_text2,0
			      C           align 4
			      C           .code
			      C         invoke LoadLibrary,ADDR library_name
			      C         mov ecx, eax
			      C         invoke GetProcAddress,eax,ADDR proc_name
			      C         EXITM <eax>
			      C       ENDM
			      C 
			      C     ; **********************************
			      C     ; control flow macro by Greg Falen *
			      C     ; **********************************
			      C 
			      C     ; ----------------------
			      C     ; Switch/Case emulation
			      C     ; ----------------------
 = 			      C     $casflg equ <>
 = 			      C     $casvar equ <>
 = 			      C     $casstk equ <>
			      C     
			      C     switch macro _var:req, _reg:=<eax>
			      C         mov _reg, _var
			      C         $casstk catstr <_reg>, <#>, $casflg, <#>, $casstk
			      C         $casvar equ _reg
			      C         $casflg equ <0>         ;; 0 = emit an .if, 1 an .elseif
			      C     endm
			      C     
			      C     case macro _args:vararg     ;; like Pascal: case id1. id4 .. id8, lparam, ...
			      C                                 ; does an or (case1 || case2 || case3...)
			      C       $cas textequ <>
			      C       irp $v, <_args>         ;; for each case
			      C           t@ instr <$v>, <..> ;; range ?
			      C           if t@               ;; yes
			      C               $LB substr <$v>, 1, t@-1                  ;; lbound = left portion
			      C               $LB catstr <(>, $casvar, <!>=>, $LB, <)>  ;; ($casvar >= lbound)
			      C               $UB substr <$v>, t@+2                     ;; ubound = right portion
			      C               $UB catstr <(>, $casvar, <!<=>, $UB, <)>  ;; ($casvar <= ubound)
			      C               $t catstr <(>, $LB, <&&> , $UB,<)>        ;; (($casvar >= $lb) && ($casvar <= $ub))
			      C           else    ;; no, it's a value (var/const)
			      C               $t catstr <(>, $casvar, <==>, <$v>, <)>   ;; ($casvar == value)
			      C           endif
			      C           $cas catstr <|| >, $t, $cas                   ;; or this case w/ others
			      C       endm
			      C       $cas substr $cas, 3 ;; lose the extra "|| " in front
			      C         ifidn $casflg, <0> ;; 0 = 1'st case
			      C             % .if $cas ;; emit ".if"
			      C         else ;; all others
			      C             % .elseif $cas ;; emit ".elseif"
			      C         endif
			      C         $casflg equ <1> ;; NOT 1'st
			      C     endm
			      C     
			      C     default macro _default:vararg
			      C         .else
			      C         _default
			      C     endm
			      C     
			      C     endsw macro _cmd:vararg
			      C         ifidn $casstk, <>
			      C             .err <Endsw w/o Switch>
			      C         else
			      C             t@ instr $casstk, <#>
			      C             $casvar substr $casstk, 1, t@-1
			      C             $casstk substr $casstk, t@+1
			      C             t@ instr $casstk, <#>
			      C             $casflg substr $casstk, 1, t@-1
			      C             ifidn $casstk, <#>
			      C                 $casstk equ <>
			      C             else
			      C                 $casstk substr $casstk, t@+1
			      C             endif
			      C             .endif
			      C         endif
			      C     endm
			      C 
			      C   ; --------------------------------------------------
			      C   ; equates for name and case variation in macro names
			      C   ; --------------------------------------------------
 = case			      C     Case equ <case>
 = case			      C     CASE equ <case>
 = switch		      C     Switch equ <switch>
 = switch		      C     SWITCH equ <switch>
			      C 
 = endsw		      C     Endsw equ <endsw>
 = endsw		      C     EndSw equ <endsw>
 = endsw		      C     ENDSW equ <endsw>
			      C 
 = switch		      C     Select equ <switch>
 = switch		      C     select equ <switch>
 = switch		      C     SELECT equ <switch>
			      C 
 = endsw		      C     Endsel equ <endsw>
 = endsw		      C     endsel equ <endsw>
 = endsw		      C     ENDSEL equ <endsw>
			      C 
 = default		      C     Default equ <default>
 = default		      C     DEFAULT equ <default>
			      C 
 = default		      C     CaseElse equ <default>
 = default		      C     Caseelse equ <default>
 = default		      C     CASEELSE equ <default>
 = default		      C     caseelse equ <default>
			      C 
			      C     ; -------------------------------------------------------------------
			      C     ; The following 2 macros are for limiting the size of a window while
			      C     ; it is being resized. They are to be used in the WM_SIZING message.
			      C     ; -------------------------------------------------------------------
			      C     LimitWindowWidth MACRO wdth
			      C         LOCAL label
			      C         mov eax, lParam
			      C         mov ecx, (RECT PTR [eax]).right
			      C         sub ecx, (RECT PTR [eax]).left
			      C         cmp ecx, wdth
			      C         jg label
			      C       .if wParam == WMSZ_RIGHT || wParam == WMSZ_BOTTOMRIGHT || wParam == WMSZ_TOPRIGHT
			      C         mov ecx, (RECT PTR [eax]).left
			      C         add ecx, wdth
			      C         mov (RECT PTR [eax]).right, ecx
			      C       .elseif wParam == WMSZ_LEFT || wParam == WMSZ_BOTTOMLEFT || wParam == WMSZ_TOPLEFT
			      C         mov ecx, (RECT PTR [eax]).right
			      C         sub ecx, wdth
			      C         mov (RECT PTR [eax]).left, ecx
			      C       .endif
			      C       label:
			      C     ENDM
			      C 
			      C     LimitWindowHeight MACRO whgt
			      C         LOCAL label
			      C         mov eax, lParam
			      C         mov ecx, (RECT PTR [eax]).bottom
			      C         sub ecx, (RECT PTR [eax]).top
			      C         cmp ecx, whgt
			      C         jg label
			      C       .if wParam == WMSZ_TOP || wParam == WMSZ_TOPLEFT || wParam == WMSZ_TOPRIGHT
			      C         mov ecx, (RECT PTR [eax]).bottom
			      C         sub ecx, whgt
			      C         mov (RECT PTR [eax]).top, ecx
			      C       .elseif wParam == WMSZ_BOTTOM || wParam == WMSZ_BOTTOMLEFT || wParam == WMSZ_BOTTOMRIGHT
			      C         mov ecx, (RECT PTR [eax]).top
			      C         add ecx, whgt
			      C         mov (RECT PTR [eax]).bottom, ecx
			      C       .endif
			      C       label:
			      C     ENDM
			      C 
			      C     MsgBox MACRO hndl,txtmsg,titlemsg,styl
			      C       invoke MessageBox,hndl,reparg(txtmsg),reparg(titlemsg),styl
			      C     ENDM
			      C 
			      C   ; ------------------------------------------------------
			      C   ; macro for concantenating strings using the szMultiCat
			      C   ; procedure written by Alexander Yackubtchik.
			      C   ;
			      C   ; USAGE strcat buffer,str1,str2,str3 etc ...
			      C   ; 
			      C   ; buffer must be large enough to contain all of the
			      C   ; strings to append. Limit is set by maximum line
			      C   ; length in MASM.
			      C   ; ------------------------------------------------------
			      C     strcat MACRO arguments:VARARG
			      C     LOCAL txt
			      C     LOCAL pcount
			      C         txt equ <invoke szMultiCat,>        ;; lead string
			      C         pcount = 0
			      C           FOR arg, <arguments>
			      C             pcount = pcount + 1             ;; count arguments
			      C           ENDM
			      C         % pcount = pcount - 1               ;; dec 1 for 1st arg
			      C         txt CATSTR txt,%pcount              ;; append number to lead string
			      C           FOR arg, <arguments>
			      C             txt CATSTR txt,<,>,reparg(arg)
			      C           ENDM
			      C         txt                                 ;; put result in code
			      C     ENDM
			      C 
			      C   ; ----------------------------------------------
			      C   ; this version is used in the function position
			      C   ; ----------------------------------------------
			      C     cat$ MACRO arguments:VARARG
			      C       LOCAL txt
			      C       LOCAL spare
			      C       LOCAL pcount
			      C         spare equ <>
			      C           FOR arg, <arguments>
			      C             spare CATSTR spare,tstarg(arg)  ;; test if 1st arg is quoted text
			      C             EXITM                           ;; and produce error if it is
			      C           ENDM
			      C         txt equ <invoke szMultiCat,>        ;; lead string
			      C         pcount = 0
			      C           FOR arg, <arguments>
			      C             pcount = pcount + 1             ;; count arguments
			      C           ENDM
			      C         % pcount = pcount - 1               ;; dec 1 for 1st arg
			      C         txt CATSTR txt,%pcount              ;; append number to lead string
			      C           FOR arg, <arguments>
			      C             txt CATSTR txt,<,>,reparg(arg)
			      C           ENDM
			      C         txt                                 ;; put result in code
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C     ; ************************************
			      C     ; console mode text input and output *
			      C     ; ************************************
			      C 
			      C     cls MACRO                       ;; clear screen
			      C       invoke ClearScreen
			      C     ENDM
			      C 
			      C     print MACRO varname:VARARG      ;; display zero terminated string
			      C       invoke StdOut,reparg(varname)
			      C     ENDM
			      C 
			      C     write MACRO quoted_text:VARARG  ;; display quoted text
			      C       LOCAL txt
			      C       .data
			      C         txt db quoted_text,0
			      C         align 4
			      C       .code
			      C       invoke StdOut,ADDR txt
			      C     ENDM
			      C 
			      C     loc MACRO xc,yc                 ;; set cursor position
			      C       invoke locate,xc,yc
			      C     ENDM
			      C 
			      C comment * -------------------------------------
			      C 
			      C     use the "input" macro as follows,
			      C 
			      C     If you want a prompt use this version
			      C     mov lpstring, input("Type text here : ")
			      C 
			      C     If you don't need a prompt use the following
			      C     mov lpstring, input()
			      C 
			      C     NOTE : The "lpstring" is a preallocated
			      C            DWORD variable that is either LOCAL
			      C            or declared in the .DATA or .DATA?
			      C            section. Any legal name is OK.
			      C 
			      C     LIMITATION : MASM uses < > internally in its
			      C     macros so if you wish to use these symbols
			      C     in a prompt, you must use the ascii value
			      C     and not use the symbol literally.
			      C 
			      C     EXAMPLE mov var, input("Enter number here ",62," ")
			      C 
			      C     ------------------------------------------- *
			      C 
			      C     input MACRO prompt:VARARG
			      C         LOCAL txt
			      C         LOCAL buffer
			      C       IFNB <prompt>
			      C         .data
			      C           txt db prompt
			      C           buffer db 128 dup (0)
			      C           align 4
			      C         .code
			      C         invoke StdOut,ADDR txt
			      C         invoke StdIn,ADDR buffer,LENGTHOF buffer
			      C         invoke StripLF,ADDR buffer
			      C         mov eax, offset buffer
			      C         EXITM <eax>
			      C       ELSE
			      C         .data
			      C           buffer db 128 dup (0)
			      C           align 4
			      C         .code
			      C         invoke StdIn,ADDR buffer,LENGTHOF buffer
			      C         invoke StripLF,ADDR buffer
			      C         mov eax, offset buffer
			      C         EXITM <eax>
			      C       ENDIF
			      C     ENDM
			      C 
			      C     exit MACRO 
			      C       invoke ExitProcess, 0
			      C     ENDM
			      C 
			      C     ; **************************
			      C     ; Application startup code *
			      C     ; **************************
			      C 
			      C       AppStart MACRO
			      C         .code
			      C         start:
			      C         invoke GetModuleHandle, NULL
			      C         mov hInstance, eax
			      C 
			      C         invoke GetCommandLine
			      C         mov CommandLine, eax
			      C 
			      C         invoke InitCommonControls
			      C 
			      C         invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT
			      C         invoke ExitProcess,eax
			      C       ENDM
			      C 
			      C     ; --------------------------------------------------------------
			      C     ; Specifies processor, memory model & case sensitive option.
			      C     ; The parameter "Processor" should be in the form ".386" etc..
			      C     ; EXAMPLE : AppModel .586
			      C     ; --------------------------------------------------------------
			      C       AppModel MACRO Processor
			      C         Processor             ;; Processor type
			      C         .model flat, stdcall  ; 32 bit memory model
			      C         option casemap :none  ;; case sensitive
			      C       ENDM
			      C 
			      C     ; --------------------------------------------
			      C     ; The following two macros must be used as a
			      C     ; pair and can only be used once in a module.
			      C     ; Additional code for processing within the
			      C     ; message loop can be placed between them.
			      C     ;
			      C     ; The single parameter passed to both macros
			      C     ; is the name of the MSG structure and must be
			      C     ; the same in both macros.
			      C     ; --------------------------------------------
			      C 
			      C       BeginMessageLoop MACRO mStruct
			      C         MessageLoopStart:
			      C           invoke GetMessage,ADDR mStruct,NULL,0,0
			      C           cmp eax, 0
			      C           je MessageLoopExit
			      C       ENDM
			      C 
			      C       EndMessageLoop MACRO mStruct
			      C           invoke TranslateMessage, ADDR mStruct
			      C           invoke DispatchMessage,  ADDR mStruct
			      C           jmp MessageLoopStart
			      C         MessageLoopExit:
			      C       ENDM
			      C 
			      C     ; ********************************************
			      C     ; align memory                               *
			      C     ; reg has the address of the memory to align *
			      C     ; number is the required alignment           *
			      C     ; EXAMPLE : memalign esi, 16                 *
			      C     ; ********************************************
			      C 
			      C       memalign MACRO reg, number
			      C         add reg, number - 1
			      C         and reg, -number
			      C       ENDM
			      C 
			      C ; ---------------------------------------------------------------------
			      C ;
			      C ; The GLOBALS macro is for allocating uninitialised data in the .DATA?
			      C ; section. It is designed to take multiple definitions to make
			      C ; allocating uninitialised data more intuitive while coding.
			      C ;
			      C ; EXAMPLE: GLOBALS item1 dd ?,\
			      C ;                  item2 dd ?,\
			      C ;                  item3 dw ?,\
			      C ;                  item4 db 128 dup (?)
			      C ;
			      C ; ---------------------------------------------------------------------
			      C 
			      C       GLOBALS MACRO var1,var2,var3,var4,var5,var6,var7,var8,var9,var0,
			      C                     varA,varB,varC,varD,varE,varF,varG,varH,varI,varJ
			      C         .data?
			      C           align 4
			      C           var1
			      C           var2
			      C           var3
			      C           var4
			      C           var5
			      C           var6
			      C           var7
			      C           var8
			      C           var9
			      C           var0
			      C           varA
			      C           varB
			      C           varC
			      C           varD
			      C           varE
			      C           varF
			      C           varG
			      C           varH
			      C           varI
			      C           varJ
			      C         .code
			      C       ENDM
			      C 
			      C     ; **********************
			      C     ; miscellaneous macros *
			      C     ; **********************
			      C 
			      C       ShellAboutBox MACRO handle,IconHandle,quoted_Text_1,quoted_Text_2:VARARG
			      C         LOCAL AboutTitle,AboutMsg,buffer
			      C 
			      C         .data
			      C           align 4
			      C           buffer db 128 dup (0)
			      C           AboutTitle db quoted_Text_1,0
			      C           AboutMsg   db quoted_Text_2,0
			      C           align 4
			      C         .code
			      C 
			      C         mov esi, offset AboutTitle
			      C         mov edi, offset buffer
			      C         mov ecx, lengthof AboutTitle
			      C         rep movsb
			      C         
			      C         invoke ShellAbout,handle,ADDR buffer,ADDR AboutMsg,IconHandle
			      C       ENDM
			      C 
			      C ; ------------------------------------------------------------------
			      C ; macro for making STDCALL procedure and API calls.
			      C ; ------------------------------------------------------------------
			      C 
			      C     Scall MACRO name:REQ,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12, \
			      C                      p13,p14,p15,p16,p17,p18,p19,p20,p21,p22
			      C 
			      C     ; ---------------------------------------
			      C     ; loop through arguments backwards, push
			      C     ; NON blank ones and call the function.
			      C     ; ---------------------------------------
			      C 
			      C       FOR arg,<p22,p21,p20,p19,p18,p17,p16,p15,p14,p13,\
			      C                p12,p11,p10,p9,p8,p7,p6,p5,p4,p3,p2,p1>
			      C         IFNB <arg>    ;; If not blank
			      C           push arg    ;; push parameter
			      C         ENDIF
			      C       ENDM
			      C 
			      C       call name       ;; call the procedure
			      C 
			      C     ENDM
			      C 
			      C     ; -------------------------------
			      C     ; pascal calling convention macro
			      C     ; left to right push
			      C     ; -------------------------------
			      C       Pcall MACRO name:REQ,items:VARARG
			      C         LOCAL arg
			      C         FOR arg,<items>
			      C           push arg
			      C         ENDM
			      C           call name
			      C       ENDM
			      C 
			      C     ; ---------------------------------------
			      C     ; Append literal string to end of buffer
			      C     ; ---------------------------------------
			      C       Append MACRO buffer,text
			      C         LOCAL szTxt
			      C         .data
			      C           szTxt db text,0
			      C           align 4
			      C         .code
			      C         invoke szCatStr,ADDR buffer,ADDR szTxt
			      C       ENDM
			      C 
			      C     ; ---------------------------
			      C     ; Put ascii zero at 1st byte
			      C     ; ---------------------------
			      C       zero1 MACRO membuf
			      C         mov membuf[0], 0
			      C       ENDM
			      C 
			      C     ; -------------------------------------------
			      C     ; put zero terminated string in .data section
			      C     ; alternative to the szText MACRO
			      C     ; -------------------------------------------
			      C       dsText MACRO Name, Text:VARARG
			      C       .data
			      C         Name db Text,0
			      C         align 4
			      C       .code
			      C       ENDM
			      C 
			      C     ; -------------------------------
			      C     ; make 2 WORD values into a DWORD
			      C     ; result in eax
			      C     ; -------------------------------
			      C       MAKEDWORD MACRO LoWord,HiWord
			      C         mov ax, HiWord
			      C         ror eax, 16
			      C         mov ax, LoWord
			      C       ENDM
			      C 
			      C     ; -----------------------------
			      C     ; return IMMEDIATE value in eax
			      C     ; -----------------------------
			      C       retval MACRO var
			      C         IF var EQ 0
			      C           xor eax, eax  ; slightly more efficient for zero
			      C         ELSE
			      C           mov eax, var  ;; place value in eax
			      C         ENDIF
			      C         ret
			      C       ENDM
			      C 
			      C     ; ------------------------
			      C     ; inline memory copy macro
			      C     ; ------------------------
			      C       Mcopy MACRO lpSource,lpDest,len
			      C         mov esi, lpSource
			      C         mov edi, lpDest
			      C         mov ecx, len
			      C         rep movsb
			      C       ENDM
			      C 
			      C     ; -----------------------------------
			      C     ; INPUT red, green & blue BYTE values
			      C     ; OUTPUT DWORD COLORREF value in eax
			      C     ; -----------------------------------
			      C       RGB MACRO red, green, blue
			      C         xor eax, eax
			      C         mov ah, blue    ; blue
			      C         mov al, green   ; green
			      C         rol eax, 16
			      C         mov al, red     ; red
			      C       ENDM
			      C 
			      C     ; ------------------------------------------------
			      C     ; The following macro were written by Ron Thomas
			      C     ; ------------------------------------------------
			      C     ; Retrieves the low word from double word argument
			      C     ; ------------------------------------------------
			      C       LOWORD MACRO bigword  
			      C         mov  eax,bigword
			      C         and  eax,0FFFFh     ; Set to low word 
			      C       ENDM
			      C 
			      C     ; ----------------------
			      C     ; fast lodsb replacement
			      C     ; ----------------------
			      C       lob MACRO
			      C         mov al, [esi]
			      C         inc esi
			      C       ENDM
			      C 
			      C     ; ----------------------
			      C     ; fast stosb replacement
			      C     ; ----------------------
			      C       stb MACRO
			      C         mov [edi], al
			      C         inc edi
			      C       ENDM
			      C 
			      C     ; ----------------------------
			      C     ; code section text insertion
			      C     ; ----------------------------
			      C       szText MACRO Name, Text:VARARG
			      C         LOCAL lbl
			      C           jmp lbl
			      C             Name db Text,0
			      C           lbl:
			      C         ENDM
			      C 
			      C       return MACRO arg
			      C         mov eax, arg
			      C         ret
			      C       ENDM
			      C 
			      C       SingleInstanceOnly MACRO lpClassName
			      C         invoke FindWindow,lpClassName,NULL
			      C         cmp eax, 0
			      C         je @F
			      C           push eax
			      C           invoke ShowWindow,eax,SW_RESTORE
			      C           pop eax
			      C           invoke SetForegroundWindow,eax
			      C           mov eax, 0
			      C           ret
			      C         @@:
			      C       ENDM
			      C 
			      C     ; macro encapsulates the MAX_PATH size buffer and returns its OFFSET
			      C 
			      C       DropFileName MACRO wordparam
			      C         IFNDEF df@@name
			      C           .data?
			      C             dfname db MAX_PATH dup (?)
			      C           .code
			      C         df@@name equ 1
			      C         ENDIF
			      C         invoke DragQueryFile,wordparam,0,ADDR dfname,SIZEOF dfname
			      C         EXITM <OFFSET dfname>
			      C       ENDM
			      C 
			      C ; д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д
			      C 
			      C comment й ------------------------------------------------------------------
			      C 
			      C     *************************************************************
			      C     * NOTE:                                                     *
			      C     * This macro system is not supported in MASM32 and is still *
			      C     * in the development stage where it is subject to change.   *
			      C     *************************************************************
			      C 
			      C                       Function declaration macros
			      C 
			      C     This macro system is designed for simplifying procedure calls
			      C     by removing the "invoke" syntax so that it can be called
			      C     directly by its name. It works by prepending "FN_" to
			      C     the procedure name and then using an equate to match the
			      C     required procedure name to the modified name.
			      C 
			      C     MyFunc equ <invoke FN_MyFunc,>
			      C 
			      C     Writing the FUNCTION is done with the FUNCTION macro and
			      C     terminated with the ENDFN macro.
			      C 
			      C     FUNCTION MyFunc,parameters
			      C       ; write code here
			      C       ret
			      C     ENDFN
			      C 
			      C     When you use the procedure, the equate is expanded up to its
			      C     full name with the leading FN_ prepended by INVOKE. This allows,
			      C 
			      C         MyFunc Parameters
			      C 
			      C         rather than
			      C 
			      C         invoke MyFunc,parameters
			      C 
			      C     When you need to use the original procedure name there is another
			      C     macro called FPTR which handles the leading FN_ so that if you have
			      C     to specify the OFFSET of the procedure or use CALL, you get the
			      C     correct address by way of the correct label name being substituted
			      C     in the body of the code that uses it.
			      C 
			      C     Instead of using code like,
			      C 
			      C         "mov wc.lpfnWndProc, offset WndProc"
			      C 
			      C         you use
			      C 
			      C         "mov wc.lpfnWndProc, offset FPTR(WndProc)"
			      C 
			      C     --------------------------------------------------------------------- й
			      C 
			      C   ; -------------------------------------
			      C   ; function prototype declaration macro
			      C   ; -------------------------------------
			      C 
			      C     DECLARE MACRO cname,parameters:VARARG
			      C       LOCAL txt,fname
			      C       fname equ <FN_>
			      C       fname CATSTR fname,<cname>
			      C       txt CATSTR fname
			      C       fname CATSTR fname,< PROTO parameters>
			      C       fname
			      C       cname equ <invoke txt,>
			      C     ENDM
			      C 
			      C   ; ---------------------
			      C   ; begin function macro
			      C   ; ---------------------
			      C     FUNCTION MACRO procname,parameters:VARARG
			      C       LOCAL txt
			      C       fn@@name@?? equ <FN_>
			      C       fn@@name@?? CATSTR fn@@name@??,<procname>     ;; write name for ENDFN
			      C       txt equ <FN_>
			      C       txt CATSTR txt,<procname proc parameters>
			      C       align 4
			      C       txt
			      C     ENDM
			      C 
			      C   ; -------------------
			      C   ; end function macro
			      C   ; -------------------
			      C     ENDFN MACRO
			      C       fn@@name@?? endp
			      C     ENDM
			      C 
 = ENDFN		      C     ENDF equ <ENDFN>
			      C 
			      C   ; -----------------------
			      C   ; function pointer macro
			      C   ; -----------------------
			      C     FPTR MACRO parameter
			      C       LOCAL txt
			      C       txt equ <FN_>
			      C       txt CATSTR txt,<parameter>
			      C       EXITM <txt>
			      C     ENDM
			      C 
			      C   ; ----------------------------
			      C   ; function return value macro
			      C   ; ----------------------------
			      C     RV MACRO args:VARARG
			      C       args
			      C       EXITM <eax>
			      C     ENDM
			      C 
			      C ; д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д=ў=д
			      C 
				    includelib masm32.lib
				    includelib kernel32.lib
 00000000			    .code
 00000000			    start:
 00000000			      print "Hello world"
 00000000 00000000	     2	        .data
 00000000 48 65 6C 6C 6F     2	          ??0000 db "Hello world",0        
	   20 77 6F 72 6C
	   64 00
 00000000		     2	        .code
 00000000
				      exit
 00000011			    end start

Microsoft (R) Macro Assembler Version 6.15.8803		    09/01/20 13:42:39
flat_wiki0.ASM						     Symbols 2 - 1




Macros:

                N a m e                 Type

ASM  . . . . . . . . . . . . . .	Func
AppModel . . . . . . . . . . . .	Proc
AppStart . . . . . . . . . . . .	Proc
Append . . . . . . . . . . . . .	Proc
BeginMessageLoop . . . . . . . .	Proc
CADD . . . . . . . . . . . . . .	Func
CTXT . . . . . . . . . . . . . .	Func
CurDir$  . . . . . . . . . . . .	Func
DDPROTO  . . . . . . . . . . . .	Func
DECLARE  . . . . . . . . . . . .	Proc
DropFileName . . . . . . . . . .	Func
ENDFN  . . . . . . . . . . . . .	Proc
EndMessageLoop . . . . . . . . .	Proc
FLOAT10  . . . . . . . . . . . .	Proc
FLOAT4 . . . . . . . . . . . . .	Proc
FLOAT8 . . . . . . . . . . . . .	Proc
FP10 . . . . . . . . . . . . . .	Func
FP4  . . . . . . . . . . . . . .	Func
FP8  . . . . . . . . . . . . . .	Func
FPTR . . . . . . . . . . . . . .	Func
FUNCTION . . . . . . . . . . . .	Proc
FUNC . . . . . . . . . . . . . .	Func
GLOBALS  . . . . . . . . . . . .	Proc
GLOBAL . . . . . . . . . . . . .	Proc
GetDllProc . . . . . . . . . . .	Func
InputFile  . . . . . . . . . . .	Func
LOWORD . . . . . . . . . . . . .	Proc
LimitWindowHeight  . . . . . . .	Proc
LimitWindowWidth . . . . . . . .	Proc
LoadProcAddress  . . . . . . . .	Proc
MAKEDWORD  . . . . . . . . . . .	Proc
MakeIP . . . . . . . . . . . . .	Func
Mcopy  . . . . . . . . . . . . .	Proc
MsgBox . . . . . . . . . . . . .	Proc
OpenFileDlg  . . . . . . . . . .	Func
OutputFile . . . . . . . . . . .	Func
Pcall  . . . . . . . . . . . . .	Proc
RGB  . . . . . . . . . . . . . .	Proc
RV . . . . . . . . . . . . . . .	Func
SADD . . . . . . . . . . . . . .	Func
STRING . . . . . . . . . . . . .	Proc
SaveFileDlg  . . . . . . . . . .	Func
Scall  . . . . . . . . . . . . .	Proc
ShellAboutBox  . . . . . . . . .	Proc
SingleInstanceOnly . . . . . . .	Proc
SysDir$  . . . . . . . . . . . .	Func
WinDir$  . . . . . . . . . . . .	Func
add$ . . . . . . . . . . . . . .	Func
alloc$ . . . . . . . . . . . . .	Func
alloc  . . . . . . . . . . . . .	Func
append$  . . . . . . . . . . . .	Func
case . . . . . . . . . . . . . .	Proc
cat$ . . . . . . . . . . . . . .	Func
chdir  . . . . . . . . . . . . .	Proc
chr$ . . . . . . . . . . . . . .	Func
cls  . . . . . . . . . . . . . .	Proc
cmd$ . . . . . . . . . . . . . .	Func
cst  . . . . . . . . . . . . . .	Proc
default  . . . . . . . . . . . .	Proc
dsText . . . . . . . . . . . . .	Proc
endsw  . . . . . . . . . . . . .	Proc
exit . . . . . . . . . . . . . .	Proc
fld10  . . . . . . . . . . . . .	Proc
fld4 . . . . . . . . . . . . . .	Proc
fld8 . . . . . . . . . . . . . .	Proc
fn . . . . . . . . . . . . . . .	Proc
free$  . . . . . . . . . . . . .	Proc
free . . . . . . . . . . . . . .	Proc
hex$ . . . . . . . . . . . . . .	Func
hval . . . . . . . . . . . . . .	Func
input  . . . . . . . . . . . . .	Func
istring  . . . . . . . . . . . .	Func
lcase$ . . . . . . . . . . . . .	Func
left$  . . . . . . . . . . . . .	Func
len  . . . . . . . . . . . . . .	Func
literal  . . . . . . . . . . . .	Func
lob  . . . . . . . . . . . . . .	Proc
loc  . . . . . . . . . . . . . .	Proc
ltrim$ . . . . . . . . . . . . .	Func
m2m  . . . . . . . . . . . . . .	Proc
memalign . . . . . . . . . . . .	Proc
mkdir  . . . . . . . . . . . . .	Proc
print  . . . . . . . . . . . . .	Proc
pth$ . . . . . . . . . . . . . .	Func
ptr$ . . . . . . . . . . . . . .	Func
remove$  . . . . . . . . . . . .	Func
reparg . . . . . . . . . . . . .	Func
return . . . . . . . . . . . . .	Proc
retval . . . . . . . . . . . . .	Proc
rev$ . . . . . . . . . . . . . .	Func
right$ . . . . . . . . . . . . .	Func
rmdir  . . . . . . . . . . . . .	Proc
rndir  . . . . . . . . . . . . .	Proc
rtrim$ . . . . . . . . . . . . .	Func
sas  . . . . . . . . . . . . . .	Proc
sstr$  . . . . . . . . . . . . .	Func
stb  . . . . . . . . . . . . . .	Proc
str$ . . . . . . . . . . . . . .	Func
stralloc . . . . . . . . . . . .	Proc
strcat . . . . . . . . . . . . .	Proc
strfree  . . . . . . . . . . . .	Proc
sval . . . . . . . . . . . . . .	Func
switch . . . . . . . . . . . . .	Proc
szText . . . . . . . . . . . . .	Proc
trim$  . . . . . . . . . . . . .	Func
tstarg . . . . . . . . . . . . .	Func
ucase$ . . . . . . . . . . . . .	Func
uhex$  . . . . . . . . . . . . .	Func
ustr$  . . . . . . . . . . . . .	Func
uval . . . . . . . . . . . . . .	Func
write  . . . . . . . . . . . . .	Proc
zero1  . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 0000000C DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000011 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

$$$00001 . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000000 Private STDCALL
$$$00002 . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000011 Private STDCALL
AboutBox . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddAtomA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AddAtomW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AllocConsole . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AllocateUserPhysicalPages  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Alloc  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AreFileApisANSI  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ArgClC . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ArgCl  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AsciiDump  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
AssignProcessToJobObject . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BMBinSearch  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BMHBinsearch . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BackupRead . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BackupSeek . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BackupWrite  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Beep . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BeginUpdateResourceA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BeginUpdateResourceW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BinSearch  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BindIoCompletionCallback . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BitmapFromFile . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BitmapFromMemory . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BitmapFromResource . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BmpButton  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BrowseForFolder  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBAndTimeoutsA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBAndTimeoutsW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
BuildCommDCBW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallNamedPipeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CallNamedPipeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelDeviceWakeupRequest  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelIo . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CancelWaitableTimer  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ChangeTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClearCommBreak . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClearCommError . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ClearScreen  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseMMF . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ColorDialog  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CombSortA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CombSortD  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CommConfigDialogA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CommConfigDialogW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CompareFileTime  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CompareStringA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CompareStringW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ConnectNamedPipe . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ContinueDebugEvent . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ConvertDefaultLocale . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ConvertThreadToFiber . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileExA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileExW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CopyFileW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateConsoleScreenBuffer  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateDirectoryW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateEventA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateEventW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFiber  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileMappingA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileMappingW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateHardLinkA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateHardLinkW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateIoCompletionPort . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateJobObjectA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateJobObjectW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMMF  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMailslotA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMailslotW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMutexA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateMutexW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateNamedPipeA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateNamedPipeW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreatePipe . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateProcessA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateProcessW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateRemoteThread . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateSemaphoreA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateSemaphoreW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateTapePartition  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateThread . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateTimerQueue . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateToolhelp32Snapshot . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWaitableTimerA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateWaitableTimerW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DebugActiveProcess . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DebugBreak . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefineDosDeviceA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DefineDosDeviceW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteAtom . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteCriticalSection  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteFiber  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteFileW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteTimerQueueEx . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteTimerQueueTimer  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteTimerQueue . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteVolumeMountPointA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeleteVolumeMountPointW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DeviceIoControl  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisableThreadLibraryCalls  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisconnectNamedPipe  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisplayBmp . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DisplayIcon  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DnsHostnameToComputerNameA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DnsHostnameToComputerNameW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DosDateTimeToFileTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DuplicateHandle  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndUpdateResourceA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EndUpdateResourceW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnterCriticalSection . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoExA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoExW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumCalendarInfoW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumDateFormatsW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumLanguageGroupLocalesA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumLanguageGroupLocalesW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceLanguagesA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceLanguagesW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceNamesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceNamesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceTypesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumResourceTypesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemCodePagesA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemCodePagesW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLanguageGroupsA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLanguageGroupsW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLocalesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumSystemLocalesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumTimeFormatsA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumTimeFormatsW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumUILanguagesA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EnumUILanguagesW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EraseTape  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
EscapeCommFunction . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitThread . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExpandEnvironmentStringsA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExpandEnvironmentStringsW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FatalAppExitA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FatalAppExitW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FatalExit  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToLocalFileTime  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillConsoleOutputAttribute . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillConsoleOutputCharacterA  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FillConsoleOutputCharacterW  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindAtomA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindAtomW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindCloseChangeNotification  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindClose  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstChangeNotificationA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstChangeNotificationW . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileExA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileExW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstFileW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeMountPointA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeMountPointW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindFirstVolumeW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextChangeNotification . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextFileA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextFileW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeMountPointA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeMountPointW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindNextVolumeW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceExA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceExW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindResourceW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindVolumeClose  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FindVolumeMountPointClose  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatToStr2  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FloatToStr . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushFileBuffers . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushInstructionCache  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushViewOfFile  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FoldStringA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FoldStringW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FontDialog . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Frame3D  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FrameCtrl  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FrameGrp . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FrameWindow  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeConsole  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeEnvironmentStringsA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeEnvironmentStringsW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeLibraryAndExitThread . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeLibrary  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeResource . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FreeUserPhysicalPages  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Free . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GenerateConsoleCtrlEvent . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetACP . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAppPath . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAtomNameA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetAtomNameW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetBinaryTypeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetBinaryTypeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCL  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCPInfoExA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCPInfoExW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCPInfo  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCalendarInfoA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCalendarInfoW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommConfig  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommMask  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommModemStatus . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommProperties  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommState . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommTimeouts  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCompressedFileSizeA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCompressedFileSizeW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetComputerNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleOutputCP . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleTitleW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrencyFormatA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrencyFormatW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentDirectoryA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentDirectoryW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentProcessId  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentProcess  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentThreadId . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCurrentThread . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateFormatA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateFormatW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDefaultCommConfigA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDefaultCommConfigW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDevicePowerState  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceExA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceExW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDiskFreeSpaceW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDriveTypeA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDriveTypeW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentStringsA . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentStringsW . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentVariableA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetEnvironmentVariableW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetErrDescription  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetExitCodeProcess . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetExitCodeThread  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesExA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesExW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileAttributesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileInformationByHandle . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileSizeEx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileSize  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileType  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFile  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFullPathNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFullPathNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetHandleInformation . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetIP  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLargestConsoleWindowSize  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocaleInfoA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocaleInfoW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLogicalDriveStringsA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLogicalDriveStringsW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLogicalDrives . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLongPathNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLongPathNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMailslotInfo  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleFileNameA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleFileNameW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleHandleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetModuleHandleW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNamedPipeHandleStateA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNamedPipeHandleStateW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNamedPipeInfo . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberFormatA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberFormatW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleMouseButtons .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetOEMCP . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetOverlappedResult  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPathOnly  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPercent . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPriorityClass . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileIntA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileIntW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionA  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionNamesA .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionNamesW .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileSectionW  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStringA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStringW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStructA . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetPrivateProfileStructW . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcAddress . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessAffinityMask . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeaps  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessIoCounters . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessPriorityBoost  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessShutdownParameters . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessTimes  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessVersion  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessWorkingSetSize . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileIntA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileIntW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileSectionA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileSectionW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileStringA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProfileStringW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetQueuedCompletionStatus  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetShortPathNameA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetShortPathNameW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStartupInfoA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStartupInfoW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeExA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeExW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStringTypeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDefaultLCID . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDefaultLangID . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDefaultUILanguage . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDirectoryA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemDirectoryW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemInfo  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemPowerStatus . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTimeAdjustment  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTimeAsFileTime  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemWindowsDirectoryA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemWindowsDirectoryW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTapeParameters  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTapePosition  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTapeStatus  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempFileNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempFileNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempPathA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTempPathW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextInput . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadContext . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadLocale  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadPriorityBoost . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadPriority  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadSelectorEntry . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetThreadTimes . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTimeFormatA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTimeFormatW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTimeZoneInformation . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserDefaultLCID . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserDefaultLangID . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetUserDefaultUILanguage . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersionExA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersionExW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVersion . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeInformationA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeInformationW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeNameForVolumeMountPointA 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumeNameForVolumeMountPointW 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumePathNameA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetVolumePathNameW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowsDirectoryA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWindowsDirectoryW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetWriteWatch  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalAddAtomA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalAddAtomW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalAlloc  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalCompact  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalDeleteAtom . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFindAtomA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFindAtomW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFix  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFlags  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalFree . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalGetAtomNameA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalGetAtomNameW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalLock . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalMemoryStatusEx . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalMemoryStatus . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalReAlloc  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalSize . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalUnWire . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalUnfix  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalUnlock . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GlobalWire . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32First  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32ListFirst  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32ListNext . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Heap32Next . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCompact  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapLock . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapReAlloc  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapUnlock . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapValidate . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapWalk . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HexDump  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IPtoString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InString . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitAtomTable  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitializeCriticalSectionAndSpinCount 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitializeCriticalSection  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntDiv . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntMul . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IntSqrt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedCompareExchange . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedDecrement . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedExchangeAdd . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedExchange  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InterlockedIncrement . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadCodePtr . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadHugeReadPtr . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadHugeWritePtr  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadReadPtr . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadStringPtrA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadStringPtrW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsBadWritePtr  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDBCSLeadByteEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDBCSLeadByte . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDebuggerPresent  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsProcessorFeaturePresent  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsSystemResumeAutomatic  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsValidCodePage  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsValidLanguageGroup . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsValidLocale  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LCMapStringA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LCMapStringW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LeaveCriticalSection . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryExA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryExW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadLibraryW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadList . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadModule . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LoadResource . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalAlloc . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalCompact . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFileTimeToFileTime  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFlags . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalLock  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalReAlloc . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalShrink  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalSize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalUnlock  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockFileEx . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LockResource . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapUserPhysicalPagesScatter  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapUserPhysicalPages . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapViewOfFileEx  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MapViewOfFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MemCopy  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Module32FirstW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Module32First  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Module32NextW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Module32Next . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileExA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileExW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileWithProgressA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileWithProgressW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveFileW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MulDiv . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MultiByteToWideChar  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
NameFromPath . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenEventA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenEventW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFileDialog . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFileMappingA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFileMappingW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenJobObjectA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenJobObjectW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenMutexA . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenMutexW . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenSemaphoreA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenSemaphoreW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenThread . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenWaitableTimerA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenWaitableTimerW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputDebugStringA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputDebugStringW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PageSetupDialog  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekNamedPipe  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PostQueuedCompletionStatus . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrepareTape  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrintDialog  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Process32FirstW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Process32First . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Process32NextW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Process32Next  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ProcessIdToSessionId . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PulseEvent . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PurgeComm  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryDosDeviceA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryDosDeviceW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryInformationJobObject  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryPerformanceCounter  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueryPerformanceFrequency  . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueueUserAPC . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
QueueUserWorkItem  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RaiseException . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputW  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputAttribute . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputCharacterA  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputCharacterW  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleOutputW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDirectoryChangesW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFileEx . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFileScatter  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadProcessMemory  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Read_File_In . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterWaitForSingleObjectEx  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RegisterWaitForSingleObject  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReleaseMutex . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReleaseSemaphore . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveDirectoryA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RemoveDirectoryW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReplaceFileA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReplaceFileW . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RequestDeviceWakeup  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RequestWakeupLatency . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ResetEvent . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ResetWriteWatch  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ResumeThread . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RichEd1  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RichEd2  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RolData  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RorData  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlFillMemory  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlMoveMemory  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlUnwind  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RtlZeroMemory  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SBMBinSearch . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SaveFileDialog . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScrollConsoleScreenBufferA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ScrollConsoleScreenBufferW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SearchPathA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SearchPathW  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetBMcolor . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCalendarInfoA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCalendarInfoW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommBreak . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommConfig  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommMask  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommState . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCommTimeouts  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameExA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameExW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetComputerNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleActiveScreenBuffer . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCtrlHandler  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursor . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleOutputCP . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCriticalSectionSpinCount  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCurrentDirectoryA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetCurrentDirectoryW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDefaultCommConfigA  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetDefaultCommConfigW  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEndOfFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEnvironmentVariableA  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEnvironmentVariableW  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetErrorMode . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetEvent . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileApisToANSI  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileApisToOEM . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileAttributesA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileAttributesW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointerEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetHandleCount . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetHandleInformation . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetInformationJobObject  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocaleInfoA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocaleInfoW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMailslotInfo  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetMessageWaitingIndicator . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetNamedPipeHandleState  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetPriorityClass . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessAffinityMask . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessPriorityBoost  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessShutdownParameters . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetProcessWorkingSetSize . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSystemPowerState  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSystemTimeAdjustment  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTapeParameters  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTapePosition  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadAffinityMask  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadContext . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadExecutionState  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadIdealProcessor  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadLocale  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadPriorityBoost . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetThreadPriority  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTimeZoneInformation . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTimerQueueTimer . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetUnhandledExceptionFilter  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeLabelA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeLabelW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeMountPointA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetVolumeMountPointW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetWaitableTimer . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetupComm  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SignalObjectAndWait  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SizeofResource . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SleepEx  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdIn  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StdOut . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLen . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrToFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StripLF  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StripRangeI  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StripRangeX  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SuspendThread  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SwitchToFiber  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SwitchToThread . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToTzSpecificLocalTime 	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TerminateJobObject . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TerminateProcess . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TerminateThread  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Thread32First  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Thread32Next . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsAlloc . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsFree  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsGetValue  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TlsSetValue  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Toolhelp32ReadProcessMemory  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TransactNamedPipe  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TransmitCommChar . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
TryEnterCriticalSection  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnhandledExceptionFilter . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnlockFileEx . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnlockFile . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnmapViewOfFile  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterWaitEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UnregisterWait . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UpdateResourceA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
UpdateResourceW  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerLanguageNameA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerLanguageNameW . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerSetConditionMask  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerifyVersionInfoA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerifyVersionInfoW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerticalTile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualAllocEx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualAlloc . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualFreeEx  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualFree  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualLock  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualProtectEx . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualProtect . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualQueryEx . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualQuery . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VirtualUnlock  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitCommEvent  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForDebugEvent  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForMultipleObjectsEx . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForMultipleObjects . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForSingleObjectEx  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitForSingleObject  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitNamedPipeA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitNamedPipeW . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WideCharToMultiByte  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WinExec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WordCount  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleInputA . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleInputW . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterW . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleW  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFileEx  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFileGather  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileSectionA  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileSectionW  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStringA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStringW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStructA . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WritePrivateProfileStructW . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProcessMemory . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileSectionA . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileSectionW . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileStringA  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteProfileStringW  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteTapemark  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Write_To_Disk  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
XorData  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_hread . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_hwrite  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lclose  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lcreat  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_llseek  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lopen . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lread . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
_lwrite  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
a2dw . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
a2wc . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr_add  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr_mul  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
arr_sub  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
atodw  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
atol . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
byte_count . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
circle . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
create_array . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dw2ah  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dw2a . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dw2hex . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
dwtoa  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
exist  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
filesize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
htodw  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
line . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
load_drives  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
locate . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcatA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcatW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpiA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcmpiW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpyA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpyW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpynA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrcpynW  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrlenA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
lstrlenW . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ltoa . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
memfill  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nrQsortA . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nrQsortD . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nrandom  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
nseed  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ofCallBack . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
read_disk_file . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
sfCallBack . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
shell  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCatStr . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCmpi . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCmp  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szCopy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLeft . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLen  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLower  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szLtrim  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szMid  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szMultiCat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
szRemove . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szRev  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szRight  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szRtrim  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szTrim . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szUpper  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
szappend . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
testreg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
udw2str  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ustr2dw  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
write_disk_file  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

$casflg  . . . . . . . . . . . .	Text   	 
$casstk  . . . . . . . . . . . .	Text   	 
$casvar  . . . . . . . . . . . .	Text   	 
??0000 . . . . . . . . . . . . .	Byte	 00000000 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
AddAtom  . . . . . . . . . . . .	Text   	 AddAtomA
BeginUpdateResource  . . . . . .	Text   	 BeginUpdateResourceA
BuildCommDCBAndTimeouts  . . . .	Text   	 BuildCommDCBAndTimeoutsA
BuildCommDCB . . . . . . . . . .	Text   	 BuildCommDCBA
CASEELSE . . . . . . . . . . . .	Text   	 default
CASE . . . . . . . . . . . . . .	Text   	 case
CHDIR  . . . . . . . . . . . . .	Text   	 chdir
CallNamedPipe  . . . . . . . . .	Text   	 CallNamedPipeA
CaseElse . . . . . . . . . . . .	Text   	 default
Caseelse . . . . . . . . . . . .	Text   	 default
Case . . . . . . . . . . . . . .	Text   	 case
CommConfigDialog . . . . . . . .	Text   	 CommConfigDialogA
CompareString  . . . . . . . . .	Text   	 CompareStringA
CopyFileEx . . . . . . . . . . .	Text   	 CopyFileExA
CopyFile . . . . . . . . . . . .	Text   	 CopyFileA
CreateDirectoryEx  . . . . . . .	Text   	 CreateDirectoryExA
CreateDirectory  . . . . . . . .	Text   	 CreateDirectoryA
CreateEvent  . . . . . . . . . .	Text   	 CreateEventA
CreateFileMapping  . . . . . . .	Text   	 CreateFileMappingA
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
CreateHardLink . . . . . . . . .	Text   	 CreateHardLinkA
CreateJobObject  . . . . . . . .	Text   	 CreateJobObjectA
CreateMailslot . . . . . . . . .	Text   	 CreateMailslotA
CreateMutex  . . . . . . . . . .	Text   	 CreateMutexA
CreateNamedPipe  . . . . . . . .	Text   	 CreateNamedPipeA
CreateProcess  . . . . . . . . .	Text   	 CreateProcessA
CreateSemaphore  . . . . . . . .	Text   	 CreateSemaphoreA
CreateWaitableTimer  . . . . . .	Text   	 CreateWaitableTimerA
DEFAULT  . . . . . . . . . . . .	Text   	 default
Default  . . . . . . . . . . . .	Text   	 default
DefineDosDevice  . . . . . . . .	Text   	 DefineDosDeviceA
DeleteFile . . . . . . . . . . .	Text   	 DeleteFileA
DeleteVolumeMountPoint . . . . .	Text   	 DeleteVolumeMountPointA
DnsHostnameToComputerName  . . .	Text   	 DnsHostnameToComputerNameA
ENDF . . . . . . . . . . . . . .	Text   	 ENDFN
ENDSEL . . . . . . . . . . . . .	Text   	 endsw
ENDSW  . . . . . . . . . . . . .	Text   	 endsw
EndSw  . . . . . . . . . . . . .	Text   	 endsw
EndUpdateResource  . . . . . . .	Text   	 EndUpdateResourceA
Endsel . . . . . . . . . . . . .	Text   	 endsw
Endsw  . . . . . . . . . . . . .	Text   	 endsw
EnumCalendarInfoEx . . . . . . .	Text   	 EnumCalendarInfoExA
EnumCalendarInfo . . . . . . . .	Text   	 EnumCalendarInfoA
EnumDateFormatsEx  . . . . . . .	Text   	 EnumDateFormatsExA
EnumDateFormats  . . . . . . . .	Text   	 EnumDateFormatsA
EnumLanguageGroupLocales . . . .	Text   	 EnumLanguageGroupLocalesA
EnumResourceLanguages  . . . . .	Text   	 EnumResourceLanguagesA
EnumResourceNames  . . . . . . .	Text   	 EnumResourceNamesA
EnumResourceTypes  . . . . . . .	Text   	 EnumResourceTypesA
EnumSystemCodePages  . . . . . .	Text   	 EnumSystemCodePagesA
EnumSystemLanguageGroups . . . .	Text   	 EnumSystemLanguageGroupsA
EnumSystemLocales  . . . . . . .	Text   	 EnumSystemLocalesA
EnumTimeFormats  . . . . . . . .	Text   	 EnumTimeFormatsA
EnumUILanguages  . . . . . . . .	Text   	 EnumUILanguagesA
ExpandEnvironmentStrings . . . .	Text   	 ExpandEnvironmentStringsA
FatalAppExit . . . . . . . . . .	Text   	 FatalAppExitA
FillConsoleOutputCharacter . . .	Text   	 FillConsoleOutputCharacterA
FindAtom . . . . . . . . . . . .	Text   	 FindAtomA
FindFirstChangeNotification  . .	Text   	 FindFirstChangeNotificationA
FindFirstFileEx  . . . . . . . .	Text   	 FindFirstFileExA
FindFirstFile  . . . . . . . . .	Text   	 FindFirstFileA
FindFirstVolumeMountPoint  . . .	Text   	 FindFirstVolumeMountPointA
FindFirstVolume  . . . . . . . .	Text   	 FindFirstVolumeA
FindNextFile . . . . . . . . . .	Text   	 FindNextFileA
FindNextVolumeMountPoint . . . .	Text   	 FindNextVolumeMountPointA
FindNextVolume . . . . . . . . .	Text   	 FindNextVolumeA
FindResourceEx . . . . . . . . .	Text   	 FindResourceExA
FindResource . . . . . . . . . .	Text   	 FindResourceA
FoldString . . . . . . . . . . .	Text   	 FoldStringA
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
FreeEnvironmentStrings . . . . .	Text   	 FreeEnvironmentStringsA
GetAtomName  . . . . . . . . . .	Text   	 GetAtomNameA
GetBinaryType  . . . . . . . . .	Text   	 GetBinaryTypeA
GetCPInfoEx  . . . . . . . . . .	Text   	 GetCPInfoExA
GetCalendarInfo  . . . . . . . .	Text   	 GetCalendarInfoA
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
GetCompressedFileSize  . . . . .	Text   	 GetCompressedFileSizeA
GetComputerNameEx  . . . . . . .	Text   	 GetComputerNameExA
GetComputerName  . . . . . . . .	Text   	 GetComputerNameA
GetConsoleTitle  . . . . . . . .	Text   	 GetConsoleTitleA
GetCurrencyFormat  . . . . . . .	Text   	 GetCurrencyFormatA
GetCurrentDirectory  . . . . . .	Text   	 GetCurrentDirectoryA
GetDateFormat  . . . . . . . . .	Text   	 GetDateFormatA
GetDefaultCommConfig . . . . . .	Text   	 GetDefaultCommConfigA
GetDiskFreeSpaceEx . . . . . . .	Text   	 GetDiskFreeSpaceExA
GetDiskFreeSpace . . . . . . . .	Text   	 GetDiskFreeSpaceA
GetDriveType . . . . . . . . . .	Text   	 GetDriveTypeA
GetEnvironmentStrings  . . . . .	Text   	 GetEnvironmentStringsA
GetEnvironmentVariable . . . . .	Text   	 GetEnvironmentVariableA
GetFileAttributesEx  . . . . . .	Text   	 GetFileAttributesExA
GetFileAttributes  . . . . . . .	Text   	 GetFileAttributesA
GetFullPathName  . . . . . . . .	Text   	 GetFullPathNameA
GetLocaleInfo  . . . . . . . . .	Text   	 GetLocaleInfoA
GetLogicalDriveStrings . . . . .	Text   	 GetLogicalDriveStringsA
GetLongPathName  . . . . . . . .	Text   	 GetLongPathNameA
GetModuleFileName  . . . . . . .	Text   	 GetModuleFileNameA
GetModuleHandle  . . . . . . . .	Text   	 GetModuleHandleA
GetNamedPipeHandleState  . . . .	Text   	 GetNamedPipeHandleStateA
GetNumberFormat  . . . . . . . .	Text   	 GetNumberFormatA
GetPrivateProfileInt . . . . . .	Text   	 GetPrivateProfileIntA
GetPrivateProfileSectionNames  .	Text   	 GetPrivateProfileSectionNamesA
GetPrivateProfileSection . . . .	Text   	 GetPrivateProfileSectionA
GetPrivateProfileString  . . . .	Text   	 GetPrivateProfileStringA
GetPrivateProfileStruct  . . . .	Text   	 GetPrivateProfileStructA
GetProfileInt  . . . . . . . . .	Text   	 GetProfileIntA
GetProfileSection  . . . . . . .	Text   	 GetProfileSectionA
GetProfileString . . . . . . . .	Text   	 GetProfileStringA
GetShortPathName . . . . . . . .	Text   	 GetShortPathNameA
GetStartupInfo . . . . . . . . .	Text   	 GetStartupInfoA
GetStringTypeEx  . . . . . . . .	Text   	 GetStringTypeExA
GetStringType  . . . . . . . . .	Text   	 GetStringTypeA
GetSystemDirectory . . . . . . .	Text   	 GetSystemDirectoryA
GetSystemWindowsDirectory  . . .	Text   	 GetSystemWindowsDirectoryA
GetTempFileName  . . . . . . . .	Text   	 GetTempFileNameA
GetTempPath  . . . . . . . . . .	Text   	 GetTempPathA
GetTimeFormat  . . . . . . . . .	Text   	 GetTimeFormatA
GetVersionEx . . . . . . . . . .	Text   	 GetVersionExA
GetVolumeInformation . . . . . .	Text   	 GetVolumeInformationA
GetVolumeNameForVolumeMountPoint .	Text   	 GetVolumeNameForVolumeMountPointA
GetVolumePathName  . . . . . . .	Text   	 GetVolumePathNameA
GetWindowsDirectory  . . . . . .	Text   	 GetWindowsDirectoryA
GlobalAddAtom  . . . . . . . . .	Text   	 GlobalAddAtomA
GlobalFindAtom . . . . . . . . .	Text   	 GlobalFindAtomA
GlobalGetAtomName  . . . . . . .	Text   	 GlobalGetAtomNameA
IsBadStringPtr . . . . . . . . .	Text   	 IsBadStringPtrA
LCMapString  . . . . . . . . . .	Text   	 LCMapStringA
LoadLibraryEx  . . . . . . . . .	Text   	 LoadLibraryExA
LoadLibrary  . . . . . . . . . .	Text   	 LoadLibraryA
MKDIR  . . . . . . . . . . . . .	Text   	 mkdir
MoveFileEx . . . . . . . . . . .	Text   	 MoveFileExA
MoveFileWithProgress . . . . . .	Text   	 MoveFileWithProgressA
MoveFile . . . . . . . . . . . .	Text   	 MoveFileA
OpenEvent  . . . . . . . . . . .	Text   	 OpenEventA
OpenFileMapping  . . . . . . . .	Text   	 OpenFileMappingA
OpenJobObject  . . . . . . . . .	Text   	 OpenJobObjectA
OpenMutex  . . . . . . . . . . .	Text   	 OpenMutexA
OpenSemaphore  . . . . . . . . .	Text   	 OpenSemaphoreA
OpenWaitableTimer  . . . . . . .	Text   	 OpenWaitableTimerA
OutputDebugString  . . . . . . .	Text   	 OutputDebugStringA
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
QueryDosDevice . . . . . . . . .	Text   	 QueryDosDeviceA
RMDIR  . . . . . . . . . . . . .	Text   	 rmdir
RNDIR  . . . . . . . . . . . . .	Text   	 rndir
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsoleOutputCharacter . . .	Text   	 ReadConsoleOutputCharacterA
ReadConsoleOutput  . . . . . . .	Text   	 ReadConsoleOutputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
RemoveDirectory  . . . . . . . .	Text   	 RemoveDirectoryA
ReplaceFile  . . . . . . . . . .	Text   	 ReplaceFileA
SELECT . . . . . . . . . . . . .	Text   	 switch
SWITCH . . . . . . . . . . . . .	Text   	 switch
ScrollConsoleScreenBuffer  . . .	Text   	 ScrollConsoleScreenBufferA
SearchPath . . . . . . . . . . .	Text   	 SearchPathA
Select . . . . . . . . . . . . .	Text   	 switch
SetCalendarInfo  . . . . . . . .	Text   	 SetCalendarInfoA
SetComputerNameEx  . . . . . . .	Text   	 SetComputerNameExA
SetComputerName  . . . . . . . .	Text   	 SetComputerNameA
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
SetCurrentDirectory  . . . . . .	Text   	 SetCurrentDirectoryA
SetDefaultCommConfig . . . . . .	Text   	 SetDefaultCommConfigA
SetEnvironmentVariable . . . . .	Text   	 SetEnvironmentVariableA
SetFileAttributes  . . . . . . .	Text   	 SetFileAttributesA
SetLocaleInfo  . . . . . . . . .	Text   	 SetLocaleInfoA
SetVolumeLabel . . . . . . . . .	Text   	 SetVolumeLabelA
SetVolumeMountPoint  . . . . . .	Text   	 SetVolumeMountPointA
Switch . . . . . . . . . . . . .	Text   	 switch
UpdateResource . . . . . . . . .	Text   	 UpdateResourceA
VerLanguageName  . . . . . . . .	Text   	 VerLanguageNameA
VerifyVersionInfo  . . . . . . .	Text   	 VerifyVersionInfoA
WaitNamedPipe  . . . . . . . . .	Text   	 WaitNamedPipeA
WriteConsoleInput  . . . . . . .	Text   	 WriteConsoleInputA
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsoleOutput . . . . . . .	Text   	 WriteConsoleOutputA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
WritePrivateProfileSection . . .	Text   	 WritePrivateProfileSectionA
WritePrivateProfileString  . . .	Text   	 WritePrivateProfileStringA
WritePrivateProfileStruct  . . .	Text   	 WritePrivateProfileStructA
WriteProfileSection  . . . . . .	Text   	 WriteProfileSectionA
WriteProfileString . . . . . . .	Text   	 WriteProfileStringA
caseelse . . . . . . . . . . . .	Text   	 default
cmpsi  . . . . . . . . . . . . .	Text   	 szCmpi
cmpstr . . . . . . . . . . . . .	Text   	 szCmp
endsel . . . . . . . . . . . . .	Text   	 endsw
lcase  . . . . . . . . . . . . .	Text   	 szLower
lnstr  . . . . . . . . . . . . .	Text   	 szLen
lstrcat  . . . . . . . . . . . .	Text   	 lstrcatA
lstrcmpi . . . . . . . . . . . .	Text   	 lstrcmpiA
lstrcmp  . . . . . . . . . . . .	Text   	 lstrcmpA
lstrcpyn . . . . . . . . . . . .	Text   	 lstrcpynA
lstrcpy  . . . . . . . . . . . .	Text   	 lstrcpyA
lstrlen  . . . . . . . . . . . .	Text   	 lstrlenA
lstr . . . . . . . . . . . . . .	Text   	 szLeft
ltrim  . . . . . . . . . . . . .	Text   	 szLtrim
midstr . . . . . . . . . . . . .	Text   	 szMid
quot . . . . . . . . . . . . . .	Text   	 "
revstr . . . . . . . . . . . . .	Text   	 szRev
rstr . . . . . . . . . . . . . .	Text   	 szRight
rtrim  . . . . . . . . . . . . .	Text   	 szRtrim
select . . . . . . . . . . . . .	Text   	 switch
start  . . . . . . . . . . . . .	L Near	 00000000 _TEXT	Public STDCALL
trim . . . . . . . . . . . . . .	Text   	 szTrim
ucase  . . . . . . . . . . . . .	Text   	 szUpper
val  . . . . . . . . . . . . . .	Text   	 uval

	   0 Warnings
	   0 Errors
